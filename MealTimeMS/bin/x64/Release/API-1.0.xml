<?xml version="1.0"?>
<doc>
    <assembly>
        <name>API-1.0</name>
    </assembly>
    <members>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.AnalogTracePointEventArgs">
            <summary>
            This implementation of EventArgs carries an <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTracePoint"/>.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTraceContainer"/> for an example how this class can be used.
            <para>
            An instance of this class will be created by <see cref="E:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTraceContainer.AnalogTracePointArrived"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.AnalogTracePointEventArgs.#ctor">
            <summary>
            Create a new <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.AnalogTracePointEventArgs"/>.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.AnalogTracePointEventArgs.TracePoint">
            <summary>
            Get access to the analog trace point that has just arrived from the instrument.
            It has replaced already the LastValue in the <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTraceContainer"/>.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.IParameterDescription">
            <summary>
            This interface has information about a possible Set argument for an <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IValue"/> or
            a property in a Scan parameter set.
            </summary>
            <remarks>
            An instance of this class will be created by <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IValue.SetParameterDescription"/> or by
            <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.PossibleParameters"/> or by
            IExactiveValue.Commands.
            </remarks>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IParameterDescription.Name">
            <summary>
            This is the name of the command/property this parameter description belongs to.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IParameterDescription.Selection">
            <summary>
            The selection is a little bit complicated. It can have these values:
            <list type="table">
            <listheader><description>value/example</description><description>description</description></listheader>
            <item><description>empty</description><description>This empty string is allowed and doesn't allow the user any selection</description></item>
            <item><description>string</description><description>This special value (verbatim "string") allows the user to enter an arbitrary string</description></item>
            <item><description>num1-num2</description><description>Integer selection between num1 and num2 inclusively</description></item>
            <item><description>num1.frac-num2.frac</description><description>Floating point selection between num1.frac and num2.frac inclusively, frac may be "0"</description></item>
            <item><description>selection1,selection2,...</description><description>lets the user select one of the shown values</description></item>
            </list>
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IParameterDescription.DefaultValue">
            <summary>
            This value will be the default value for the argument or
            the empty string if it is unknown.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IParameterDescription.Help">
            <summary>
            This returns the empty string or some help about the command/property.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTraceContainer">
             <summary>
             All analog trace points of the instrument can be accessed by using this
             interface.
             <para>
             The last-seen value is accessible all the time but may change frequently.
             It is also possible to get notice of a new value as soon as it is accessible.
             </para>
             </summary>
             <remarks>
             An instance of this class will be created by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess.GetAnalogTraceContainer(System.Int32)"/>.
             </remarks>
             <example>
             In the following example it is assumed that the instrument has two analog
             input devices as most Orbitrap systems and many other MS instruments have:
             <code>
             using System;
             using System.Collections.Generic;
             using System.Linq;
             using System.Text;
            
             using Thermo.Interfaces.ExactiveAccess_V1;
             using Thermo.Interfaces.InstrumentAccess_V1;
             using Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer;
            
             namespace UserAccess
             {
            		/// <summary>
            		/// This class displays the output of the analog channels when they arrive.
            		/// </summary>
            		internal class AnalogOutput
            		{
            			/// &lt;summary&gt;
            			/// Create a new &lt;see cref="AnalogOutput"/&gt; and make sure two analog channels are observed.
            			/// &lt;/summary&gt;
            			/// &lt;param name="instrument"&gt;the instrument instance&lt;/param&gt;
            			internal AnalogOutput(IInstrumentAccess instrument)
            			{
            				Analog1 = instrument.GetAnalogTraceContainer(0);
            				Analog1.AnalogTracePointArrived += new EventHandler{AnalogTracePointEventArgs}(Instrument_AnalogTracePointArrived);
            				Analog2 = instrument.GetAnalogTraceContainer(1);
            				Analog2.AnalogTracePointArrived += new EventHandler{AnalogTracePointEventArgs}(Instrument_AnalogTracePointArrived);
            			}
            
            			/// &lt;summary&gt;
            			/// Cleanup this instance.
            			/// &lt;/summary&gt;
            			internal void CloseDown()
            			{
            				// Be tolerant to thread-switches
            				IAnalogTraceContainer analogContainer;
            
            				analogContainer = Analog1;
            				Analog1 = null;
            				if (analogContainer != null)
            				{
            					analogContainer.AnalogTracePointArrived -= new EventHandler{AnalogTracePointEventArgs}(Instrument_AnalogTracePointArrived);
            				}
            
            				analogContainer = Analog2;
            				Analog2 = null;
            				if (analogContainer != null)
            				{
            					analogContainer.AnalogTracePointArrived -= new EventHandler{AnalogTracePointEventArgs}(Instrument_AnalogTracePointArrived);
            				}
            			}
            
            			/// &lt;summary&gt;
            			/// Access to the first analog container.
            			/// &lt;/summary&gt;
            			private IAnalogTraceContainer Analog1 { get; set; }
            
            			/// &lt;summary&gt;
            			/// Access to the second analog container.
            			/// &lt;/summary&gt;
            			private IAnalogTraceContainer Analog2 { get; set; }
            
            			/// &lt;summary&gt;
            			/// When an analog event arrives we dump the content.
            			/// &lt;/summary&gt;
            			/// &lt;param name="sender"&gt;used to identify the channel&lt;/param&gt;
            			/// &lt;param name="e"&gt;content will be dumped&lt;/param&gt;
            			private void Instrument_AnalogTracePointArrived(object sender, AnalogTracePointEventArgs e)
            			{
            				IAnalogTraceContainer analogTrace = sender as IAnalogTraceContainer;
            				if (analogTrace != null)
            				{
            					Console.WriteLine("{0}: [{1} - {2}]: {3} at {4} s", analogTrace.DetectorClass, analogTrace.Minimum, analogTrace.Maximum, e.TracePoint.Value, e.TracePoint.Occurrence.TotalSeconds);
            				}
            			}
            		}
            	}
             </code>
             </example>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTraceContainer.DetectorClass">
            <summary>
            Get access to the detector class.
            <para>
            Example: The detector name may be "PDA", but "Analog Input Channel 1"
            or something similar is also possible.
            </para>
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTraceContainer.Minimum">
            <summary>
            Get access to the lowest possible value of the detector or analog input.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTraceContainer.Maximum">
            <summary>
            Get access to the highest possible value of the detector or analog input.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTraceContainer.UpdateFrequencyHz">
            <summary>
            Get access to acquisition frequency of the values. null is returned if the
            system has no specific frequency. The value is returned in 1/s (Hertz).
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTraceContainer.LastValue">
            <summary>
            Get access to the last value seen in the system.
            The value can be null initially.
            </summary>
        </member>
        <member name="E:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTraceContainer.AnalogTracePointArrived">
            <summary>
            This event will be fired when a new analog value has been emitted by the
            instrument. There may be no specific update frequency.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer">
            <summary>
            All MS scans of the instrument can be accessed by using this
            interface.
            <para>
            The last-seen scan is accessible all the time but may change frequently.
            It is also possible to get notice of a new scan as soon as it is accessible.
            </para>
            </summary>
            <remarks>
            An instance of this class will be created by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess.GetMsScanContainer(System.Int32)"/>.
            </remarks>
            <example>
            In the following example it is assumed that the instrument has at least one
            MS device. Most functions and classes of this namesspace are used.
            <code>
            using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            
            using Thermo.Interfaces.InstrumentAccess_V1;
            using Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer;
            
            using IMsScan = Thermo.Interfaces.InstrumentAccess_V2.MsScanContainer.IMsScan;
            using ICentroid = Thermo.Interfaces.InstrumentAccess_V2.MsScanContainer.ICentroid;
            
            namespace UserAccess
            {
            	/// &lt;summary&gt;
            	/// This class presents the output of the scans being acquired by the instrument.
            	/// &lt;/summary&gt;
            	internal class ScansOutput
            	{
            		/// &lt;summary&gt;
            		/// Crate a new &lt;see cref="ScansOutput"/&gt;
            		/// &lt;/summary&gt;
            		/// &lt;param name="instrument"&gt;the instrument instance&lt;/param&gt;
            		internal ScansOutput(IInstrumentAccess instrument)
            		{
            			ScanContainer = instrument.GetMsScanContainer(0);
            			Console.WriteLine("Detector class: " + ScanContainer.DetectorClass);
            
            			ScanContainer.AcquisitionStreamOpening += new EventHandler&lt;MsAcquisitionOpeningEventArgs&gt;(ScanContainer_AcquisitionStarted);
            			ScanContainer.AcquisitionStreamClosing += new EventHandler(ScanContainer_AcquisitionEnded);
            			ScanContainer.MsScanArrived += new EventHandler&lt;MsScanEventArgs&gt;(ScanContainer_ScanArrived);
            		}
            
            		/// &lt;summary&gt;
            		/// Show the last acquired scan if that exists and cleanup.
            		/// &lt;/summary&gt;
            		internal void CloseDown()
            		{
            			// Be tolerant to thread-switches
            			IMsScanContainer scanContainer = ScanContainer;
            			ScanContainer = null;
            
            			if (scanContainer != null)
            			{
            				scanContainer.MsScanArrived -= new EventHandler&lt;MsScanEventArgs&gt;(ScanContainer_ScanArrived);
            				scanContainer.AcquisitionStreamClosing -= new EventHandler(ScanContainer_AcquisitionEnded);
            				scanContainer.AcquisitionStreamOpening -= new EventHandler&lt;MsAcquisitionOpeningEventArgs&gt;(ScanContainer_AcquisitionStarted);
            				using (IMsScan scan = (/* V2 */ IMsScan) scanContainer.GetLastMsScan())
            				{
            					DumpScan("GetLastScan()", scan);
            				}
            			}
            		}
            
            		/// &lt;summary&gt;
            		/// Access to the scan container hosted by this instance.
            		/// &lt;/summary&gt;
            		private IMsScanContainer ScanContainer { get; set; }
            
            		/// &lt;summary&gt;
            		/// When a new acquisition starts we dump that information.
            		/// &lt;/summary&gt;
            		/// &lt;param name="sender"&gt;doesn't matter&lt;/param&gt;
            		/// &lt;param name="e"&gt;doesn't matter&lt;/param&gt;
            		private void ScanContainer_AcquisitionStarted(object sender, EventArgs e)
            		{
            			Console.WriteLine("START OF ACQUISITION");
            		}
            
            		/// &lt;summary&gt;
            		/// When an acquisitions ends we dump that information.
            		/// &lt;/summary&gt;
            		/// &lt;param name="sender"&gt;doesn't matter&lt;/param&gt;
            		/// &lt;param name="e"&gt;doesn't matter&lt;/param&gt;
            		private void ScanContainer_AcquisitionEnded(object sender, EventArgs e)
            		{
            			Console.WriteLine("END OF ACQUISITION");
            		}
            
            		/// &lt;summary&gt;
            		/// When a new scan arrives we dump that information in verbose mode.
            		/// &lt;/summary&gt;
            		/// &lt;param name="sender"&gt;doesn't matter&lt;/param&gt;
            		/// &lt;param name="e"&gt;used to access the scan information&lt;/param&gt;
            		private void ScanContainer_ScanArrived(object sender, MsScanEventArgs e)
            		{
            			Console.WriteLine("Scan arrived");
            			// As an example we access all centroids
            			using (IMsScan scan = (/* V2 */ IMsScan) e.GetScan())
            			{
            				DumpScan("Scan arrived", scan);
            			}
            		}
            
            		/// &lt;summary&gt;
            		/// Dump a scan and prepend it with an intro string.
            		/// &lt;/summary&gt;
            		/// &lt;param name="intro"&gt;string to prepend&lt;/param&gt;
            		/// &lt;param name="scan"&gt;thing to dump&lt;/param&gt;
            		private void DumpScan(string intro, IMsScan scan)
            		{
            			StringBuilder sb = new StringBuilder();
            			sb.AppendFormat(Instrument.Now.ToString(Program.TimeFormat));
            			sb.Append(": ");
            			sb.Append(intro);
            			sb.Append(", ");
            			if (scan == null)
            			{
            				sb.Append("(empty scan)");
            				Console.WriteLine(sb.ToString());
            				return;
            			}
            			else
            			{
            				sb.Append("detector=");
            				sb.Append(scan.DetectorName);
            				string id;
            				if (scan.SpecificInformation.TryGetValue("Access Id:", out id))
            				{
            					sb.Append(", id=");
            					sb.Append(id);
            				}
            				Console.WriteLine(sb.ToString());
            			}
            
            			// This is rather noisy, dump all variables:
            			DumpVars(scan);
            
            			Console.Write("  Noise: ");
            			foreach (INoiseNode noise in scan.NoiseBand)
            			{
            				Console.Write("[{0}, {1}], ", noise.Mz, noise.Intensity);
            			}
            			Console.WriteLine();
            
            			// Not so useful:
            			Console.WriteLine("{0} centroids, {1} profile peaks", scan.CentroidCount ?? 0, scan.ProfileCount ?? 0);
            
            			// Iterate over all centroids and access dump all profile elements for each.
            			foreach (ICentroid centroid in scan.Centroids)
            			{
            				Console.WriteLine(" {0,10:F5}, I={1:E5}, C={2}, E={3,-5} F={4,-5} M={5,-5} R={6,-5} Res={7}",
            									centroid.Mz, centroid.Intensity, centroid.Charge ?? -1, centroid.IsExceptional, centroid.IsFragmented, centroid.IsMerged, centroid.IsReferenced, centroid.Resolution);
            			if (scan.HasProfileInformation)
            			{
            				Console.Write("    Profile:");
            				try
            				{
            					foreach (IMassIntensity profilePeak in centroid.Profile)
            					{
            						Console.Write(" [{0,10:F5},{1:E5}] ", profilePeak.Mz, profilePeak.Intensity);
            					}
            				}
            				catch
            				{
            				}
            				Console.WriteLine();
            			}
            		}
            
            		/// &lt;summary&gt;
            		/// Dump all variables belonging to a scan
            		/// &lt;/summary&gt;
            		/// &lt;param name="scan"&gt;the scan for which to dump all variables&lt;/param&gt;
            		private void DumpVars(IMsScan scan)
            		{
            			Console.WriteLine("  COMMON");
            			DumpVars(scan.CommonInformation);
            			Console.WriteLine("  SPECIFIC");
            			DumpVars(scan.SpecificInformation);
            		}
            
            		/// &lt;summary&gt;
            		/// Dump all scan variables belonging to a specific container in a scan.
            		/// &lt;/summary&gt;
            		/// &lt;param name="container"&gt;container to dump all contained variables for&lt;/param&gt;
            		private void DumpVars(IInfoContainer container)
            		{
            			foreach (string s in container.Names)
            			{
            				DumpVar(container, s);
            			}
            		}
            
            		/// &lt;summary&gt;
            		/// Dump the content of a single variable to the console after testing the consistency.
            		/// &lt;/summary&gt;
            		/// &lt;param name="container"&gt;container that variable belongs to&lt;/param&gt;
            		/// &lt;param name="name"&gt;name of the variable&lt;/param&gt;
            		/// &lt;param name="sb"&gt;buffer to be reused for speed&lt;/param&gt;
            		private void DumpVar(IInfoContainer container, string name)
            		{
            			object o = null;
            			string s = null;
            			MsScanInformationSource i = MsScanInformationSource.Unknown;
            
            			if (container.TryGetValue(name, out s, ref i))
            			{
            				// i should have a reasonable value now
            				if (container.TryGetRawValue(name, out o, ref i))
            				{
            					Console.WriteLine("  {0}: type={1}, text='{2}', raw='{3}'",
            						name, i, s, o);
            				}
            			}
            		}
            	}
            }
            </code>
            </example>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer.GetLastMsScan">
            <summary>
            Get access to the last scan seen in the system.
            The value can be null initially.
            <para>
            Note that accessing this property forces the consumer to dispose
            the item as soon as possible in order to free its shared memory resources.
            </para>
            </summary>
            <returns>The method returns the latest scan the framework is aware off. It may be null. It is castable to an Thermo.Interfaces.InstrumentAccess_V2.MsScanContainer.IMsScan</returns>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer.DetectorClass">
            <summary>
            Get access to the detector class. The class should include describe
            the instrument detector set precisely, although the individual
            detector type of a scan uses only a part of the instrument set.
            <para>
            Example: The instrument name may be "Thermo Orbitrap Velos Pro", the
            detector class may be "Hybrid LinearIonTrap Orbitrap" and the
            scan detector name may be "LinearIonTrap".
            </para>
            </summary>
        </member>
        <member name="E:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer.MsScanArrived">
            <summary>
            This event will be fired when a new scan has been emitted by the
            instrument.
            <para>
            Any listener to this event must handle the event as fast as possible.
            It is good practice by analyzing tool to enqueue the scan into
            queue and process that queue in another thread.
            </para>
            </summary>
        </member>
        <member name="E:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer.AcquisitionStreamOpening">
            <summary>
            This event will be fired when a new acquisition is started and the system
            is about to open rawfiles, etc.
            <para>
            Scans may be created without an explicite acquisition if the instrument is
            'just' set to running. An acquisition is not necessarily bound to a
            rawfile, but it is in most cases.
            </para>
            <para>
            The specific information of a scan will reflect the information whether
            a scan belongs to an acquisition or not.
            </para>
            </summary>
        </member>
        <member name="E:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer.AcquisitionStreamClosing">
            <summary>
            This event will be fired when the current acquisition ended.
            <para>
            Scans may be created without an explicite acquisition, so further scans may
            arrive after an acquisition stopped. It may even be possible that few scans
            belonging to the last acquisition may arrive and that an opened rawfile
            will gather them because of a flushing data queue on the transport layer.
            </para>
            <para>
            The specific information of a scan will reflect the information whether
            a scan belongs to an acquisition or not.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScanDefinition">
            <summary>
            This interface covers the functionality to define a custom or repeating scan.
            </summary>
            <remarks>
            This is a base interface of <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.ICustomScan"/> and <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IRepeatingScan"/>.
            </remarks>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScanDefinition.Values">
            <summary>
            Get access to the value set. Any value nor defined will be replaced by the
            value defined in the default scan.
            <para>
            Illegal values will be ignored, values out of range will not be accepted.
            </para>
            <para>
            The set of possible values can be queried by accessing PossibleParameters
            in <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans"/>. The key must be an <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.IParameterDescription"/> Name,
            the value must match the Selection definition.
            </para>
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScanDefinition.RunningNumber">
            <summary>
            This number will be passed along with the scan job and can be used
            to identify it later when the acquired scan results arrive.
            0 is a reserved value. The default value is 1.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.NamespaceDoc">
            <summary>
            This namespace covers the functionality that a user may have to manipulate methods of an instrument.
            These manipulations can be applied to the running acquisition.
            <para>
            Most functionality in this namespace is accessible offline.
            </para>
            <para>
            Obtain <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl"/>.<see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl.Methods"/>
            to create the desired base class.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.StateChangedEventArgs">
            <summary>
            This implementation of EventArgs carries an <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState"/>.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition"/> for an example how this class can be used.
            <para>
            An instance of this class will be created by <see cref="E:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.StateChanged"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.StateChangedEventArgs.#ctor">
            <summary>
            Create a new <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.StateChangedEventArgs"/>.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.StateChangedEventArgs.State">
            <summary>
            Get access to the current state of the instrument.
            It has replaced already the State in the <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition"/>.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IOnMode">
            <summary>
            This mode lets an instrument enter the On state or change the behaviour in the On state.
            The request may be rejected if the instrument is in a state that should not be disturbed. See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IForcedStandbyMode"/>.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition"/> for an example how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.CreateOnMode"/>.
            </para>
            </remarks>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IMode">
            <summary>
            A mode is a more or less complex information that selects a new operation mode of an instrument.
            </summary>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IMode.ToString">
            <summary>
            This is an informational description of the new mode.
            </summary>
            <returns>The returned string gives a short description of the mode.</returns>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IMode.AdditionalValues">
            <summary>
            Get access to a collection of additional values. This will not be used in most cases.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IForcedOffMode">
            <summary>
            This mode lets an instrument enter the Off state. The request will be honoured even if the
            instrument is within an acquisition or another state where it is usually better to continue.
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IForcedOffMode"/>.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition"/> for an example how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.CreateForcedOffMode"/>.
            </para>
            </remarks>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.ChangeResult">
            <summary>
            Defines the result of a requested instrument mode change.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition"/> for an example how this enumeration can be used.
            </remarks>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.ChangeResult.Submitted">
            <summary>
            This state change request has been submitted to the instrument. The instrument itself may dishonour this request
            if the needed condition to apply the state change request have changed between the submitting and the arrival
            in the instrument.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.ChangeResult.InstrumentDisconnected">
            <summary>
            The instrument is disconnected.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.ChangeResult.IllegalValues">
            <summary>
            The state change request has illegal values.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.ChangeResult.UnknownRequestType">
            <summary>
            The state change request is of an unknown type. Use <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition"/> to generate a valid type.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.ChangeResult.ForeignControl">
            <summary>
            The instrument is under exclusive use of a different component or software package.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.ChangeResult.IllegalOperationState">
            <summary>
            The instrument is not in the proper condition to accept the state change request.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.IError">
            <summary>
            An IError describes an error coming from the instrument during an acquisition.
            This interface will not be used for status reports or messages of the
            transport layer.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.ErrorsArrivedEventArgs"/> for an example how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.ErrorsArrivedEventArgs.Errors"/>.
            </para>
            </remarks>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.IError.Content">
            <summary>
            The textual content of the error.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.IError.Occurrence">
            <summary>
            The time difference between acquisition start and this error occurred.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.ICustomScan">
            <summary>
            This scan definition can be placed in the instrument's
            job queue with individual properties. A custom scan will
            be executed only once.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans"/> for an example how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.CreateCustomScan"/>.
            </para>
            </remarks>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.ICustomScan.SingleProcessingDelay">
            <summary>
            The instrument will not execute any further custom scan
            if this property is positive until the delay has expired
            or a new custom scan has been defined.
            <para>
            The unit of this property is seconds and possible values are
            between 0 and 600 inclusively. The default value is 0.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans">
            <summary>
            This interface allows the control over the next scan to be performed by the
            instrument with or without a method.
            <para>
            Either this interface or the <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.IMethods"/> interface should be used.
            </para>
            </summary>
            <remarks>
            An instance of this class will be created by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl.GetScans(System.Boolean)"/>.
            <para>
            Using this interface allows one to insert some scans in the normal flow of
            operation. It has several three layers of execution.
            </para>
            <para>
            The lowest layer is defined by the instrument. It performs those steps that
            are defined elsewhere, this can be either method execution, tuning or other things.
            </para>
            <para>
            The next layer that has a higher priority is the repeated scans layer which are
            defined here. If they are set they will be executed instead of the previous layer.
            A further Set call replaces the previous repition. A Cancel call will stop
            the repetition and operation falls back one layer. A custom scan can still be
            defined, though. The repition can be switched on and off on demand as often
            as desired.
            </para>
            <para>
            The most prioritized layer is that of custom scans. They will be executed before
            any furcher scan defined in the other layers. However, a Set operation may result
            in undefined behaviour (but no system fault happens) if the previous scan has not been
            started yet. It is best to avoid this situation. The custom scan will be scheduled and
            the AcceptsNextScan event will be fired at the next possible point in time. If a
            custom scan has a delay time set the instrument will wait this additional time
            until it falls back to a lower layer; either the repetition scans if they are
            defined or the normal operation mode.
            </para>
            </remarks>
            <example>
            The following code illustrates the use of most functionality in this namespace.
            A running acquisition (Press "On" in Tune) will be modified so that the polarity
            will be toggled between each scan.
            <code>
            using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            using System.Threading;
            using System.Globalization;
            
            using Thermo.Interfaces.InstrumentAccess_V1;
            using Thermo.Interfaces.InstrumentAccess_V1.Control;
            using Thermo.Interfaces.InstrumentAccess_V1.Control.Scans;
            
            namespace UserAccess
            {
                /// &lt;summary&gt;
                /// This class demonstrates the use of the &lt;see cref="IScans"/&gt; interface.
                /// &lt;/summary&gt;
                internal class ScansTest : IDisposable
                {
                    private IScans m_scans;
                    private bool m_startCustomScan = true;
                    private object m_lock = new object();
                    private int m_disposed;
                    private long m_runningNumber = 12345;	// start with an offset to make sure it's "us"
                    private int m_polarity = 0;
                    
                    /// &lt;summary&gt;
                    /// Create a new &lt;see cref="ScansTest"/&gt; and start the performance test immediately.
                    /// &lt;/summary&gt;
                    /// &lt;param name="instrument"&gt;the instrument instance&lt;/param&gt;
                    /// &lt;param name="arguments"&gt;program arguments&lt;/param&gt;
                    internal ScansTest(IInstrumentAccess instrument)
                    {
                        m_scans = instrument.Control.GetScans(false);
                        m_scans.CanAcceptNextCustomScan += new EventHandler(Scans_CanAcceptNextCustomScan);
                        m_scans.PossibleParametersChanged += new EventHandler(Scans_PossibleParametersChanged);
                        
                        DumpPossibleParameters();
                        bool startNewScan = false;
                        lock (m_lock)
                        {
                            if (m_scans.PossibleParameters.Length &gt; 0)
                            {
                                startNewScan = m_startCustomScan;
                                m_startCustomScan = false;
                            }
                        }
                        
                        if (startNewScan)
                        {
                            StartNewScan();
                        }
                    }
                    
                    /// &lt;summary&gt;
                    /// The final destructor releases allocated system resources.
                    /// &lt;/summary&gt;
                    ~ScansTest()
                    {
                        // Let the GC dispose managed members itself.
                        Dispose(false);
                    }
                
                    /// &lt;summary&gt;
                    /// Clean up any resources being used.
                    /// &lt;/summary&gt;
                    /// &lt;param name="disposeEvenManagedStuff"&gt;true to dispose managed and unmanaged resources; false to dispose unmanaged resources&lt;/param&gt;
                    protected void Dispose(bool disposeEvenManagedStuff)
                    {
                        // prevent double disposing
                        if (Interlocked.Exchange(ref m_disposed, 1) != 0)
                        {
                            return;
                        }
                    
                        if (disposeEvenManagedStuff)
                        {
                            if (m_scans != null)
                            {
                                m_scans.CanAcceptNextCustomScan -= new EventHandler(Scans_CanAcceptNextCustomScan);
                                m_scans.PossibleParametersChanged -= new EventHandler(Scans_PossibleParametersChanged);
                                m_scans.Dispose();
                                m_scans = null;
                            }
                        }
                    }
                    
                    /// &lt;summary&gt;
                    /// Clean up any resources being used.
                    /// &lt;/summary&gt;
                    virtual public void Dispose()
                    {
                        // Dispose managed and unmanaged resources and tell GC we don't need the destructor getting called.
                        Dispose(true);
                        GC.SuppressFinalize(this);
                    }
                    
                    /// &lt;summary&gt;
                    /// Get access to the flag whether this object is disposed.
                    /// &lt;/summary&gt;
                    internal bool Disposed { get { return m_disposed != 0; } }
                    
                    /// &lt;summary&gt;
                    /// Dump the list of possible commands.
                    /// &lt;/summary&gt;
                    private bool DumpPossibleParameters()
                    {
                        IParameterDescription[] parameters = m_scans.PossibleParameters;
                        if (parameters.Length == 0)
                        {
                            Console.WriteLine("No possible IScans parameters known.");
                            return false;
                        }
                        
                        Console.WriteLine("IScans parameters:");
                        foreach (IParameterDescription parameter in parameters)
                        {
                            StringBuilder sb = new StringBuilder();
                            sb.AppendFormat("   '{0}' ", parameter.Name);
                            if (parameter.Selection == "")
                            {
                                sb.AppendFormat("doesn't accept an argument, help: {0}", parameter.Help);
                            }
                            else
                            {
                                sb.AppendFormat("accepts '{0}', default='{1}', help: {2}", parameter.Selection, parameter.DefaultValue, parameter.Help);
                            }
                            Console.WriteLine(sb.ToString());
                        }
                        return true;
                    }
                
                    /// &lt;summary&gt;
                    /// Start a new custom scan.
                    /// &lt;/summary&gt;
                    private void StartNewScan()
                    {
                        ICustomScan cs = m_scans.CreateCustomScan();
                        cs.RunningNumber = m_runningNumber++;
                        
                        // Allow an extra delay of 500 ms, we will answer as fast as possible, so this is a maximum value.
                        cs.SingleProcessingDelay = 0.50D;
                        
                        // Toggle the polarity:
                        m_polarity = (m_polarity == 0) ? 1 : 0;
                        cs.Values["Polarity"] = m_polarity.ToString(NumberFormatInfo.InvariantInfo);
                        
                        try
                        {
                            DateTime now = Instrument.Now;
                            if (!m_scans.SetCustomScan(cs))
                            {
                                Console.WriteLine("NEW CUSTOM SCAN HAS NOT BEEN PLACED, CONNECTION TO SERVICE BROKEN.");
                            }
                            Console.WriteLine(now.ToString(Program.TimeFormat) + ": Placed a new custom scan(" + cs.RunningNumber + ")");
                        }
                        catch (Exception e)
                        {
                            Console.WriteLine("PLACING A NEW SCAN: " + e.Message);
                        }
                    }
                    
                    /// &lt;summary&gt;
                    /// Called when the current custom scan has been processed and the next custom scan can be accepted.
                    /// We start a new scan.
                    /// &lt;/summary&gt;
                    /// &lt;param name="sender"&gt;doesn't matter&lt;/param&gt;
                    /// &lt;param name="e"&gt;doesn't matter&lt;/param&gt;
                    private void Scans_CanAcceptNextCustomScan(object sender, EventArgs e)
                    {
                        Console.WriteLine(Instrument.Now.ToString(Program.TimeFormat) + ": CanAcceptNextCustomScan");
                        if ((m_scans != null) &amp;&amp; (m_scans.PossibleParameters.Length &gt; 0))
                        {
                            // Assume we are able to place a new scan.
                            StartNewScan();
                        }
                    }
                  
                    /// &lt;summary&gt;
                    /// Called when the list of possible commands have changed we dump them.
                    /// Additionally we start a new scan.
                    /// &lt;/summary&gt;
                    /// &lt;param name="sender"&gt;doesn't matter&lt;/param&gt;
                    /// &lt;param name="e"&gt;doesn't matter&lt;/param&gt;
                    private void Scans_PossibleParametersChanged(object sender, EventArgs e)
                    {
                        if (!DumpPossibleParameters())
                        {
                            return;
                        }
                     
                        bool startNewScan = false;
                        lock (m_lock)
                        {
                            if (m_scans.PossibleParameters.Length &gt; 0)
                            {
                                startNewScan = m_startCustomScan;
                                m_startCustomScan = false;
                            }
                        }
                        
                        if (startNewScan)
                        {
                            StartNewScan();
                        }
                    }
                }
            }    
            </code>
            </example>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.SetRepetitionScan(Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IRepeatingScan)">
            <summary>
            Define or replace the repetition scan to be performed.
            <para>
            The scan may be partially defined in which case the properties of the previously
            executed scan will be used. At least one property needs to be specified.
            </para>
            </summary>
            <param name="scan">object containing new default scan definitions</param>
            <returns>true if the command has been sent to the instrument, false otherwise</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.CancelRepetition">
            <summary>
            Cancels any repetition of scans that have been defined by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.SetRepetitionScan(Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IRepeatingScan)"/>.
            </summary>
            <returns>true if the command has been sent to the instrument, false otherwise</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.SetCustomScan(Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.ICustomScan)">
            <summary>
            Define a scan to be performed next. The current standard operation (method, prepetition scan, etc)
            will continue after this scan and maybe following custom scans have been acquired.
            <para>
            The operation on the instrument is undefined if several custom scans are set without having the
            instrument dealt with the previous custom scans. However, the instrument will not stop
            to run, choke or show any other fatal error.
            </para>
            <para>
            The event <see cref="E:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.CanAcceptNextCustomScan"/> is fired once after the instrument has processed a
            custom scan. The further custom scan can be set then or within the delay time that
            might have been defined in <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.ICustomScan.SingleProcessingDelay"/>.
            </para>
            <para>
            The scan may be partially defined in which case the properties of the previously
            executed scan will be used. At least one property needs to be specified.
            </para>
            </summary>
            <param name="scan">object containing custom scan definitions</param>
            <returns>true if the command has been sent to the instrument, false otherwise</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.CancelCustomScan">
            <summary>
            Cancels any custom scan and/or the delay after that custom scan defined by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.SetCustomScan(Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.ICustomScan)"/>.
            </summary>
            <returns>true if the command has been sent to the instrument, false otherwise</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.CreateRepeatingScan">
            <summary>
            Create an empty <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IRepeatingScan"/> implementation.
            </summary>
            <returns>
            The return value will be a newly created repeating scan with default values. Assignment of properties
            is needed to let the call of <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.SetRepetitionScan(Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IRepeatingScan)"/> have an effect.
            </returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.CreateCustomScan">
            <summary>
            Create an empty <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.ICustomScan"/> implementation.
            </summary>
            <returns>
            The return value will be a newly created repeating scan with default values. Assignment of properties
            is needed to let the call of <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.SetCustomScan(Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.ICustomScan)"/> have an effect.
            </returns>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.PossibleParameters">
            <summary>
            All possible parameters of a scan will be listed here.
            </summary>
        </member>
        <member name="E:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.PossibleParametersChanged">
            <summary>
            This event will be fired when the <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.PossibleParameters"/>
            have received an update. The initial parameter set may be void
            during initialization or after an instrument reconnect.
            </summary>
        </member>
        <member name="E:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.CanAcceptNextCustomScan">
            <summary>
            The instrument raises this event when it has processed a custom scan defined by
            <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.SetCustomScan(Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.ICustomScan)"/>. It will accept a further custom scan until the
            <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.ICustomScan.SingleProcessingDelay"/> has expired or an instrument specific
            delay of few milliseconds has passed. After this time, the instrument continues
            with the previous action, usually a method or a repetition.
            <para>
            The event should be handled as fast as possible.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.IReadback">
            <summary>
            This interface describes the methods and properties of a readback. An IReadback
            is a representation of a item that provides information but does not accept any command
            or set value.
            <para>
            The content of the readback can be taken from the property <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IReadback.Content"/>.
            </para>
            </summary>
            <remarks>
            <para>
            The interface <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IValue"/> derives from this interface.
            </para>
            <para>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition"/> for an example how this interface can be used.
            </para>
            </remarks>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IReadback.Name">
            <summary>
            Get access to the name of the value.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IReadback.Content">
            <summary>
            Get access to the content of the readback. The access to this property is sufficient in most
            cases, but for values that change frequently like logging information it might be better
            to rely on the information passed along by the <see cref="E:Thermo.Interfaces.InstrumentAccess_V1.Control.IReadback.ContentChanged"/> event.
            </summary>
        </member>
        <member name="E:Thermo.Interfaces.InstrumentAccess_V1.Control.IReadback.ContentChanged">
            <summary>
            This event will be fired when the content of the readback has changed. The calling thread
            should not be blocked by complex actions. A long-term data processing should move the
            processing into a separate thread and copy the content of this event into a queue.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.NamespaceDoc">
            <summary>
            This namespace covers the central access to standard instruments of the new generation. The
            central access point is <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccessContainer"/> which serves as a master
            to get access to all other interfaces in this namespace and all contained namespaces.
            <para>
            See the documentation of <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccessContainer"/>
            for an example how to get access to this primary interface.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan">
            <summary>
            This class deals with scan specific information. The class is disposable, but the
            content will be released only under these circumstances:
            <list type="bullet">
            <item><description>The last IMsScan reference has been released.</description></item>
            <item><description>The <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer"/>'s LastScan property has changed.</description></item>
            </list>
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer"/> for an example how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer.GetLastMsScan"/> or by
            <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsScanEventArgs.GetScan"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.GetProfileData(System.Double[]@,System.Double[]@)">
            <summary>
            Get access to the profile data. The caller has to make sure that the arrays are big enough.
            The property <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.ProfileCount"/> indicates the minimum size.
            <para>
            An exception will be thrown if one of the arrays is too small to keep all profile
            peaks or if profile peaks are inaccessible, mainly because the detector doesn't support it.
            </para>
            <para>
            It is good practice to access profile information by use of <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.ICentroid"/>
            if that is possible but use <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.GetProfileData(System.Double[]@,System.Double[]@)"/> otherwise.
            </para>
            </summary>
            <param name="masses">
            Array of m/z values that will be filled up to the last element keeping valueable information.
            Extra elements will not be set to 0. The array must be big enough, see <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.ProfileCount"/>.
            </param>
            <param name="intensities">
            Array of intensities that will be filled up to the last element keeping valueable information.
            Extra elements will not be set to 0. The array must be big enough, see <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.ProfileCount"/>.
            </param>
            <returns>
            The method returns pure profile information. Although this call acts rather fast it is more helpful
            in most cases to have the relation to centroids present. The access can be performed using <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.Centroids"/>.
            </returns>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.DetectorName">
            <summary>
            Get access to the name of the detector that acquired this scan.
            <para>
            Example: The instrument name may be "Thermo Orbitrap Velos Pro", the
            detector class may be "Hybrid LinearIonTrap Orbitrap" and the
            scan detector name may be "LinearIonTrap".
            </para>
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.CommonInformation">
            <summary>
            Get access to the information being common part between all Thermo MS instruments.
            Number will be presented in US locale, default values may be omitted.
            The dictionary is read-only.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.SpecificInformation">
            <summary>
            Get access to the information being specific to this instrument class or acquisition type.
            Number will be presented in US locale, default values may be omitted.
            The dictionary is read-only.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.AdditiveNoise">
            <summary>
            This value will be true if the noise intensity information at a specific point
            has to be added to the intensity at that m/z point of an <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.ICentroid"/>
            or profile peak to get the real intensity information.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.NoiseBand">
            <summary>
            Get access to the noise information. The noise nodes form a polygon that covers the noise area.
            An empty enumeration is returned if noise information is not present.
            This value will not be null.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.HasCentroidInformation">
            <summary>
            This value will be true if centroid information is part of the scan. Even without
            centroid information there may be profile peaks. It is good practice to access
            profile information by use of <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.ICentroid"/> if that is possible but use
            <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.GetProfileData(System.Double[]@,System.Double[]@)"/> otherwise.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.CentroidCount">
            <summary>
            Get access to the number of centroids in this scan. The value is null if the detector
            is not capable to provide centroids. The value may also be null if a computation
            cannot be performed.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.Centroids">
            <summary>
            Get access to the centroids and further information to those peaks.
            An empty enumeration is returned if centroid information is not present.
            This value will not be null.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.HasProfileInformation">
            <summary>
            This value will be true if profile information is part of the scan.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.ProfileCount">
            <summary>
            Get access to the number of profile peaks in this scan. The value is null if the detector
            is not capable to provide profile peaks. The value may also be null if a computation
            cannot be performed.
            The value will always be non-null if a call to <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.GetProfileData(System.Double[]@,System.Double[]@)"/> is possible.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess">
            <summary>
            This interface describes the access to one particular instrument both for reading data
            as for managing access or behaviour of the instrument.
            <para>
            An instance of this class will be created by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccessContainer.Get(System.Int32)"/>.
            </para>
            </summary>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess.GetMsScanContainer(System.Int32)">
            <summary>
            Get access to the container of MS scan information to be accessible
            by a a specific MS detector set.
            </summary>
            <param name="msDetectorSet">index of the detector starting from 0</param>
            <remarks>
            Hybrid machines may only offer one detector set because they cannot be
            operated separately. However, it is possible that they offer detector
            specific subsets. The standard detector set has a smaller
            detector set number.
            </remarks>
            <returns>
            The mass spectrometer properties and data access points the instrument has
            for one particular MS detector.
            </returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess.GetAnalogTraceContainer(System.Int32)">
            <summary>
            Get access to the container of analog trace information to be accessible
            by a a specific analog detector set (UV, PDA, etc).
            </summary>
            <param name="analogDetectorSet">index of the detector starting from 0</param>
            <returns>
            The mass spectrometer properties and data access points the instrument has
            for one particular analog detector.
            </returns>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess.InstrumentId">
            <summary>
            Access to the id of the instrument. This is the same id as used
            to get access to this instance.
            <para>
            This property is accessible offline.
            </para>
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess.InstrumentName">
            <summary>
            Access to the name of the instrument.
            <para>
            Example: The instrument name may be "Thermo Orbitrap Velos Pro", the
            detector class may be "Hybrid LinearIonTrap Orbitrap" and the
            scan detector name may be "LinearIonTrap".
            </para>
            <para>
            This property is accessible offline.
            </para>
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess.Connected">
            <summary>
            Get access to the connection state of the instrument and of this driver to
            the communication layer. Most functionality is not available if the instrument
            is not connected.
            <para>
            This property is accessible offline.
            </para>
            </summary>
        </member>
        <member name="E:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess.ConnectionChanged">
            <summary>
            This event will be fired when the connection to the instrument changes.
            Note that the initial connection state will be disconnected until a
            connection has been established to the instrument.
            <para>
            This property is accessible offline.
            </para>
            </summary>
        </member>
        <member name="E:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess.ErrorsArrived">
            <summary>
            This event will be thrown when at least one error arrived from the instrument
            during an acquisition.
            This event handler will not be used for status reports or messages of the
            transport layer.
            <para>
            This event handler is accessible offline.
            </para>
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess.Control">
            <summary>
            Get access to the interface covering all control functionality of an instrument.
            <para>
            This property is accessible offline.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IInfoContainer">
            <summary>
            This interface describes the methods and properties to access name/value pairs
            within an <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan"/>.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer"/> for an example how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.CommonInformation"/> or by
            <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.SpecificInformation"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IInfoContainer.TryGetValue(System.String,System.String@)">
            <summary>
            Try to retrieve the textual representation of an item. Numbers will be presented
            in the US locale.
            </summary>
            <param name="name">name of the item</param>
            <param name="value">textual representation of the value of the item</param>
            <returns>true if the value has been found, false otherwise</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IInfoContainer.TryGetRawValue(System.String,System.Object@)">
            <summary>
            Try to retrieve the value of an item.
            </summary>
            <param name="name">name of the item</param>
            <param name="value">value of the item</param>
            <returns>true if the value has been found, false otherwise</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IInfoContainer.TryGetValue(System.String,System.String@,Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsScanInformationSource@)">
            <summary>
            Try to retrieve the textual representation of an item. Numbers will be presented
            in the US locale.
            </summary>
            <param name="name">name of the item</param>
            <param name="value">textual representation of the value of the item</param>
            <param name="source">
            On output it describes the source of information, on input any selection other than
            Unknown will find only an item in the specified name space.
            </param>
            <returns>true if the value has been found, false otherwise</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IInfoContainer.TryGetRawValue(System.String,System.Object@,Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsScanInformationSource@)">
            <summary>
            Try to retrieve the value of an item.
            </summary>
            <param name="name">name of the item</param>
            <param name="value">value of the item</param>
            <param name="source">
            On output it describes the source of information, on input any selection other than
            Unknown will find only an item in the specified name space.
            </param>
            <returns>true if the value has been found, false otherwise</returns>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IInfoContainer.Names">
            <summary>
            Get access to the possible names of all items within this container.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IInstrumentValues">
            <summary>
            IInstrumentValues allow access to instrument values on an individual basis.
            It is helpful for status control and direct value manipulation (e.g. system
            status, source voltages, etc).
            <para>
            A synchroneous change of several scan-related elements should better
            be performed using <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans"/>.
            </para>
            </summary>
            <remarks>
            An instance of this class will be created by <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl.InstrumentValues"/>.
            </remarks>
            <example>
            The following code illustrates the use of most functionality in this namespace.
            A known value node will be linked and dumped on changes.
            <code>
            using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            
            using Thermo.Interfaces.InstrumentAccess_V1.Control;
            using Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues;
            using Thermo.Interfaces.ExactiveAccess_V1.Control.InstrumentValues;
            
            namespace UserAccess
            {
                /// &lt;summary&gt;
                /// This class provides tests for the IInstrumentValues interface.
                /// &lt;/summary&gt;
                internal class ValuesTest
                {
                    private IValue m_instrumentAcquisition;
            	    
                    /// &lt;summary&gt;
                    /// Create a new &lt;see cref="ValuesTest"/&gt; and start the performance immediately.
                    /// &lt;/summary&gt;
                    /// &lt;param name="instrumentValues"&gt;the values access point of the instrument instance&lt;/param&gt;
                    internal ValuesTest(IInstrumentValues instrumentValues)
                    {
                        m_instrumentAcquisition = instrumentValues.Get("InstrumentAcquisition");
                        if (m_instrumentAcquisition != null)
                        {
                            m_instrumentAcquisition.ContentChanged += new EventHandler&lt;ValueContentChangedEventArgs&gt;(ContentChanged);
                            IExactiveValue exactiveValue = m_instrumentAcquisition as IExactiveValue;
                            if (exactiveValue != null)
                            {
                                exactiveValue.CommandsChanged += new EventHandler(CommandsChanged);
                            }
                            Console.WriteLine("instrument acquisition node: ID={0}, name={1}", m_instrumentAcquisition.Id, m_instrumentAcquisition.Name);
                        }
                    }
                    
                    /// &lt;summary&gt;
                    /// Cleanup this instance.
                    /// &lt;/summary&gt;
                    internal void CloseDown()
                    {
                        m_instrumentAcquisition.ContentChanged -= new EventHandler&lt;ValueContentChangedEventArgs&gt;(ContentChanged);
                        IExactiveValue exactiveValue = m_instrumentAcquisition as IExactiveValue;
                        if (exactiveValue != null)
                        {
                            exactiveValue.CommandsChanged -= new EventHandler(CommandsChanged);
                        }
                    }
                    
                    /// &lt;summary&gt;
                    /// Return the status text of a status value.
                    /// &lt;/summary&gt;
                    /// &lt;param name="contentStatus"&gt;value of the status enumeration of an instrument value&lt;/param&gt;
                    private string Status(int contentStatus)
                    {
                        switch (contentStatus)
                        {
                            case 0: return "OK";
                            case 1: return "Info";
                            case 2: return "Warning";
                            case 3: return "Error";
                            case 4: return "Fatal";
                            default: break;
                        }
                        return "Unknown";
                    }
            	    
                    /// &lt;summary&gt;
                    /// Called when the content change we print them.
                    /// &lt;/summary&gt;
                    /// &lt;param name="sender"&gt;the instrument value which value change&lt;/param&gt;
                    /// &lt;param name="e"&gt;used to extract the value&lt;/param&gt;
                    private void ContentChanged(object sender, ValueContentChangedEventArgs e)
                    {
                        IValue value = sender as IValue;
                        if (value != null)
                        {
                            if (e.Content == null)
                            {
                                Console.WriteLine("Value of ({0}) changed to null.", value.Name);
                            }
                            else if (e.Content == null)
                            {
                                Console.WriteLine("Value of ({0}) is unknown to the instrument or the connection is lost.", value.Name);
                            }
                            else
                            {
                                IValueContent content = e.Content;
                                Console.WriteLine("Value of ({0}) changed to '{1}', unit='{2}', status={3}, help='{4}'", value.Name, content.Content, content.Unit, Status(content.Status), content.Help);
                            }
                        }
                    }
                
                    /// &lt;summary&gt;
                    /// Called when the set of possible commands change we print them if we act verbosely.
                    /// &lt;/summary&gt;
                    /// &lt;param name="sender"&gt;the instrument value which commands change&lt;/param&gt;
                    /// &lt;param name="e"&gt;doesn't matter&lt;/param&gt;
                    void CommandsChanged(object sender, EventArgs e)
                    {
                        IExactiveValue value = sender as IExactiveValue;
                        if (value != null)
                        {
                            if (value.Commands.Length == 0)
                            {
                                Console.WriteLine("Commands for ({0}) are not registered", value.Name);
                            }
                            else
                            {
                                Console.WriteLine("Commands for ({0}):", value.Name);
                                foreach (IParameterDescription command in value.Commands)
                                {
                                    StringBuilder sb = new StringBuilder();
                                    sb.AppendFormat("   '{0}' ", command.Name);
                                    if (command.Selection == "")
                                    {
                                        sb.AppendFormat("doesn't accept an argument, help: {0}", command.Help);
                                    }
                                    else
                                    {
                                        sb.AppendFormat("accepts '{0}', default='{1}', help: {2}", command.Selection, command.DefaultValue, command.Help);
                                    }
                                    Console.WriteLine(sb.ToString());
                                }
                            }
                        }
                    }
                }
            }
            </code>
            </example>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IInstrumentValues.Get(System.String)">
            <summary>
            Get access to an instrument value by its name.
            <para>
            Each name has also a numeric representation, see <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IInstrumentValues.Get(System.UInt64)"/>.
            </para>
            </summary>
            <param name="name">The name of the value</param>
            <returns>null is returned for an invalid or unknown name, otherwise the value linked with the passed name is returned.</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IInstrumentValues.Get(System.UInt64)">
            <summary>
            Get access to an instrument value by its number.
            </summary>
            <param name="number">The number of the value</param>
            <returns>The value linked with the passed name is returned. Nodes unknown to the instrument may return in a dumb value instance.</returns>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IInstrumentValues.ValueNames">
            <summary>
            Get access to the list of all possible names for <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IInstrumentValues.Get(System.String)"/>.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.ICentroid">
            <summary>
            This interface describes information about a centroid peak.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer"/> for an example how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.Centroids"/>.
            </para>
            </remarks>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMassIntensity">
            <summary>
            This interface is used to store the basic information about peaks.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer"/> for an example how this interface can be used.
            <para>
            Derived classes are <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.ICentroid"/> and <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.INoiseNode"/>.
            An instance of this class will be created by <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.ICentroid.Profile"/>.
            </para>
            </remarks>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMassIntensity.Mz">
            <summary>
            m/z value of the information.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMassIntensity.Intensity">
            <summary>
            Intensity at the given m/z value.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.ICentroid.IsExceptional">
            <summary>
            Get access to the flag whether this peak is an artificial exception.
            null is returned if the value couldn't be determined.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.ICentroid.IsReferenced">
            <summary>
            Get access to the flag whether this peak is a referenced (lock mass) peak.
            null is returned if the value couldn't be determined.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.ICentroid.IsMerged">
            <summary>
            Get access to the flag whether this peak is a merged peak.
            null is returned if the value couldn't be determined.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.ICentroid.IsFragmented">
            <summary>
            Get access to the flag whether this peak is a fragmented peak.
            null is returned if the value couldn't be determined.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.ICentroid.IsMonoisotopic">
            <summary>
            Get access to the flag whether this peak is a monoisotopic peak.
            null is returned if the value couldn't be determined.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.ICentroid.Charge">
            <summary>
            Get access to the charge state.
            null is returned if this value couldn't be determined.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.ICentroid.Profile">
            <summary>
            Get access to the profile information. The return value
            will be an empty array if no profile information is related to this
            centroid.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.IInclusionTable">
            <summary>
            This flag interface defines a table which carries inclusion items.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.ITable">
            <summary>
            This interface covers the methods and properties being accessible on tables that will
            be used in the instruments like inclusion tables or exclusion tables.
            <para>
            The type of this interface cannot be used directly in <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.IMethods.CreateTable(System.Type)"/>,
            please use <c>typeof(<see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.IInclusionTable"/>)</c>, etc.
            </para>
            </summary>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.ITable.CreateRow">
            <summary>
            Create a new row which can be added to every table of the same type.
            <para>
            This method is accessible offline.
            </para>
            </summary>
            <returns>The created row can be used to extend <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.ITable.Rows"/>.</returns>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.ITable.ColumnInfo">
            <summary>
            Return information about the columns in the table.
            <para>
            This method is accessible offline.
            </para>
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.ITable.Rows">
            <summary>
            Access to the rows of the table.
            <para>
            This method is accessible offline.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.ContentChangedEventArgs">
            <summary>
            This implementation of EventArgs carries an <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.IContent"/>.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IInstrumentValues"/> for an example how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="E:Thermo.Interfaces.InstrumentAccess_V1.Control.IReadback.ContentChanged"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.ContentChangedEventArgs.#ctor">
            <summary>
            Create a new <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.ContentChangedEventArgs"/>.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.ContentChangedEventArgs.Content">
            <summary>
            Get access to the content of the value that has changed.
            It has replaced already the Content in the referenced <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IValue"/>.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState">
            <summary>
            This interface describes the current system and acquisition state.
            <para>
            A missing connection can be detected by examining <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState.SystemState"/>.
            NotConnected informs about a missing link between driver and instrument,
            ServerFailed about a missing link between the current software and the driver.
            </para>
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState.Description">
            <summary>
            This is the general description of the instrument state. The text may change even if the <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState.SystemState"/>
            and <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState.SystemMode"/> doesn't change.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState.SystemMode">
            <summary>
            The system mode returns the processing mode the instrument is currently in.
            Another state information is <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState.SystemState"/>.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState.SystemState">
            <summary>
            The system state returns the instrument state with respect to data acquisition.
            Another state information is <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState.SystemMode"/>.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState.ElapsedRuntime">
            <summary>
            During an operation (see <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState.SystemMode"/>) with a more or less defined 
            runtime this value reflects the processed time in percent of the total runtime.
            null is returned if that value is not appropriate.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState.MethodName">
            <summary>
            This value is either null or the name of the method being processed.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState.LastOpenedRawFileName">
            <summary>
            This value is either null or the name of the last opened raw file. It is the true name,
            not the expected name.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState.SequenceFileName">
            <summary>
            This value is either null or the name of the used sequence file. It is only set during
            a method execution.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState.SequenceFileIndex">
            <summary>
            This value is either null or the row number in the sequence file. The value is 1-based.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IRepeatingScan">
            <summary>
            This scan definition can be placed in the instrument's
            job queue for repetition.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans"/> for an example how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans.CreateRepeatingScan"/>.
            </para>
            </remarks>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.NamespaceDoc">
            <summary>
            This namespace covers the functionality that a user may have to start or stop the acquisition of scans.
            <para>
            Obtain <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl"/>.<see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl.Acquisition"/>
            to create the desired base class.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IValue">
            <summary>
            This interface describes the methods and properties of a value. An IValue
            is a representation of a value of various purposes in the instrument.
            <para>
            The content of the value can be taken from the property <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IReadback.Content"/>.
            </para>
            <para>
            A request for a value change will be sent to the instrument by using
            <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IValue.Set(System.String)"/>, but there is no guarantee for acceptance or execution at all.
            The <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IReadback.Content"/> or other values can be observed to test for a proper response.
            </para>
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IInstrumentValues"/> for an example how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IInstrumentValues.Get(System.UInt64)"/> or
            by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IInstrumentValues.Get(System.String)"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IValue.Set(System.String)">
            <summary>
            Set the content of the value. The command will be verified using <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IValue.SetParameterDescription"/>.
            </summary>
            <param name="argument">null or the argument of the command.</param>
            <returns>true if the value change command has been sent to the instrument, false otherwise</returns>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IValue.Id">
            <summary>
            Get access to the ID of the value.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IValue.SetParameterDescription">
            <summary>
            Get a description about the parameter to the set access to a list of available commands.
            The list may change if the user role changes.
            Any executed command name will be tested against this list.
            <para>
            The commands will be null if the instrument is not connected or if the IValue is unknown
            to the instrument or if <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IValue.Set(System.String)"/> cannot be performed for this value.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccessContainer">
            <summary>
            This interface is the central access point for a direct access of an instrument.
            It covers both online functionality as well as offline manipulation of methods.
            <para>
            Use the instrument container to get access to a particular instrument accessor by means of
            <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccessContainer.Get(System.Int32)"/>
            </para>
            <para>
            Any functionality in this interface is accessible offline.
            </para>
            </summary>
            <example>
            Every instrument family has a different scheme to access the API if such an interface
            is presented at all. In former times, Exactive series instrument provided a COM
            interface which is still accessible. A COM interface cannot provide the performance
            of a pure .NET interface. For optimal results we propose the following code in C#:
            <code>
             /// <summary>
             /// Name of the instrument in the registry.
             /// </summary>
             private const string InstrumentName = "Thermo Exactive";
             /// <summary>
             /// This string will be used as a registry value name to access the file name of the API assembly.
             /// </summary>
             private const string ApiFileNameDescriptor = "ApiFileName_Clr2_32_V1";
             /// <summary>
             /// This string will be used as a registry value name to access the class name of the API.
             /// </summary>
             private const string ApiClassNameDescriptor = "ApiClassName_Clr2_32_V1";
             /// <summary>
             /// Create an instance of the API object and return it.
             /// Exceptions will be thrown on errors.
             /// </summary>
             private IInstrumentAccessContainer GetApiInstance()
             {
             	string baseName = @"SOFTWARE\Finnigan\Xcalibur\Devices\" + InstrumentName;
             	using (RegistryKey key = Registry.LocalMachine.OpenSubKey(baseName))
             	{
             		if (key != null)
             		{
             			string asmName = (string) key.GetValue(ApiFileNameDescriptor, null);
             			string typeName = (string) key.GetValue(ApiClassNameDescriptor, null);
             			if (!string.IsNullOrEmpty(asmName) &amp;&amp; !string.IsNullOrEmpty(typeName))
             			{
             				Assembly asm = Assembly.LoadFrom(asmName);
             				return (IInstrumentAccessContainer) asm.CreateInstance(typeName);
             			}
             		}
             	}
             	throw new Exception("Cannot find API information of instrument \"" + InstrumentName + "\" in the registry.");
             }
            </code>
            <para>
             The example code load the API assembly and the main class in the memory of the executing process.
            </para>
            </example>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccessContainer.Get(System.Int32)">
            <summary>
            Get access to a particular instrument accessor using this method. All calls within one
            process will return an instance that share the same 'real' instrument accessor.
            This will ensure maximum speed. Multithreaded code is still supported.
            <para>
            The returned object is disposable, it will count down the usage count
            on each disposal. The connection to the instrument is dropped when the last
            instrument access instance is disposed.
            </para>
            </summary>
            <example>
            A typical use can be performed by .NET's <c>using</c> statement as shown
            here. This ensures proper disposal after use:
            <code>
            using (IInstrumentAccess instrument = container.Get(1))
            {
            	// further code
            }
            </code>
            </example>
            <param name="index">
            Index of the instrument starting from 1. Values of 2 or more need additional
            instruments attached to the data system.
            </param>
            <returns>
            The return value allows access to a particular instrument. If one service hosts
            several instruments in parallel, this value can be of a different type for each.
            Furthermore, the return class instance may implement other interfaces beside
            <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess"/>.
            </returns>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition">
            <summary>
            This interface allows the direct access to method/acquisition starts, to
            wait for contact closure or to extend the delay between the start of
            the acquisition process and the real start of the first scan
            programmatically. 
            </summary>
            <remarks>
            An instance of this class will be created by <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl.Acquisition"/>.
            </remarks>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.SetMode(Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IMode)">
            <summary>
            Transport a new state change request to the instrument. Even if the command has been
            submitted successfully to the instrument it may still be possible that the instrument
            rejects the request because it has entered a different state in between.
            </summary>
            <param name="newMode">The new mode that shall be assumed by the instrument.</param>
            <returns>The result of the state change request as far as the task is processed in the current process</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.Pause">
            <summary>
            Pause the current operation.
            </summary>
            <returns>true if it was possible to pause the operation and if the pause command has been transmitted to the instrument.</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.Resume">
            <summary>
            Resume the current operation.
            </summary>
            <returns>true if it was possible to resume the operation from a pause and if the resume command has been transmitted to the instrument.</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.CreateOnMode">
            <summary>
            Create a new state change object that can put the instrument in the On state.
            No data acquisition will be performed, a separate command/logic exists for this purpose.
            </summary>
            <returns>The created state change object can be used in <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.SetMode(Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IMode)"/> to set the new state.</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.CreateOffMode">
            <summary>
            Create a new state change object that can put the instrument in the Off state.
            </summary>
            <returns>The created state change object can be used in <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.SetMode(Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IMode)"/> to set the new mode.</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.CreateStandbyMode">
            <summary>
            Create a new state change object that can put the instrument in the Standby state.
            </summary>
            <returns>The created state change object can be used in <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.SetMode(Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IMode)"/> to set the new state.</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.CreateForcedOffMode">
            <summary>
            Create a new state change object that can put the instrument in the Off state unconditionally. A running acquisition even started by a a foreign control may be terminated.
            </summary>
            <returns>The created state change object can be used in <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.SetMode(Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IMode)"/> to set the new mode.</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.CreateForcedStandbyMode">
            <summary>
            Create a new state change object that can put the instrument in the Standby state unconditionally. A running acquisition even started by a a foreign control may be terminated.
            </summary>
            <returns>The created state change object can be used in <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.SetMode(Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IMode)"/> to set the new state.</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.WaitFor(System.TimeSpan,Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode[])">
            <summary>
            Wait for the instrument to assume one of several <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode"/>s during a specific time interval
            starting from the time it was submitted.
            <para>
            Passing no modes at all will let this call wait the desired duration.
            </para>
            </summary>
            <param name="duration">non-negative duration this call shall wait at most</param>
            <param name="modes">List of modes for which this call looks. If one is assumed the call returns immediately.</param>
            <returns>true if one of the listed modes has been assumed during the timespan, false otherwise</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.WaitFor(System.TimeSpan,Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState[])">
            <summary>
            Wait for the instrument to assume one of several <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState"/>s during a specific time interval
            starting from the time it was submitted.
            <para>
            Passing no states at all will let this call wait the desired duration.
            </para>
            </summary>
            <param name="duration">non-negative duration this call shall wait at most</param>
            <param name="states">List of states for which this call looks. If one is assumed the call returns immediately.</param>
            <returns>true if one of the listed states has been assumed during the timespan, false otherwise</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.WaitForOtherThan(System.TimeSpan,Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode[])">
            <summary>
            Wait for the instrument to assume another than those <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode"/>s given in a list during a specific time interval
            starting from the time it was submitted.
            <para>
            Passing no modes at all will force an immediate return.
            </para>
            </summary>
            <param name="duration">non-negative duration this call shall wait at most</param>
            <param name="modes">List of modes for which this call looks. If none is assumed the call returns immediately.</param>
            <returns>true if none of the listed modes has been assumed during the timespan, false otherwise</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.WaitForOtherThan(System.TimeSpan,Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState[])">
            <summary>
            Wait for the instrument to assume another than those <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState"/>s given in a list during a specific time interval
            starting from the time it was submitted.
            <para>
            Passing no states at all will force an immediate return.
            </para>
            </summary>
            <param name="duration">non-negative duration this call shall wait at most</param>
            <param name="states">List of states for which this call looks. If none is assumed the call returns immediately.</param>
            <returns>true if none of the listed states has been assumed during the timespan, false otherwise</returns>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.State">
            <summary>
            Get access to the current state of the instrument.
            </summary>
        </member>
        <member name="E:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.StateChanged">
            <summary>
            This event will be fired after <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.State"/> has changed its value. The current
            instrument state will be carried along.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.CanPause">
            <summary>
            Will it be possible to pause the current operation?
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.CanResume">
            <summary>
            Will it be possible to pause the current operation?
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.NamespaceDoc">
            <summary>
            This namespace covers those interfaces for sole use by mass spectrometers.
            <para>
            Call <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess"/>.<see cref="M:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess.GetMsScanContainer(System.Int32)"/>
            to create the desired base class.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.IMethods">
            <summary>
            This interface defines all actions that belong to method-based data
            acquisition and for method-based information access.
            </summary>
            <remarks>
            An instance of this class will be created by <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl"/>.<see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl.Methods"/>.
            </remarks>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.IMethods.CreateTable(System.Type)">
            <summary>
            Create a table of the passed type.
            <para>
            This method is accessible offline.
            </para>
            </summary>
            <param name="tableType">Type of the table which has to derive from ITable like IInclusionTable</param>
            <returns>The created table can be used to call <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.IMethods.ReplaceTable(System.Int32,System.Int64,Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.ITable)"/>.</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.IMethods.ReplaceTable(System.Int32,System.Int64,Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.ITable)">
            <summary>
            Replace a table currently used by the instrument.
            </summary>
            <param name="tableIndex">Index of the table starting from 1. Keep this on 1 in case of doubt.</param>
            <param name="runningNumber">This value will be reflected by the instrument in the scan so that the point in time becomes clear when the instrument used the updated table the first time. It is under the responsibility of the user to change this value. 0 is a reserved value.</param>
            <param name="table">The new table to be used. The table can be empty, but null will raise an exception.</param>
            <returns>true if the command has been sent to the instrument, false otherwise</returns>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.IMethods.LoadTable(System.String,System.Int32,System.Type)">
            <summary>
            Load a table of the passed type with the specified table index from a named method file. This is an expensive operation.
            An exception will be thrown if the method doesn't exist.
            <para>
            This method is accessible offline.
            </para>
            </summary>
            <param name="methodName">Name of the method file.</param>
            <param name="tableIndex">index of the table starting with 1.</param>
            <param name="tableType">Type of the table which has to derive from ITable like IInclusionTable</param>
            <returns>null if the table was not found, otherwise the table filled with found items.</returns>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl">
            <summary>
            This interface covers all control functionality of an instrument.
            </summary>
            <remarks>
            An instance of this class will be created by <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess.Control"/>.
            </remarks>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl.GetScans(System.Boolean)">
            <summary>
            Get access to the scans interface. This interface allows to execute
            repeating and custum scans during a method or any other execution.
            <para>
            Calling this method will lock that interface until it is disposed.
            The instrument will not stop its current operation for the first.
            If exclusive access is requested it will be guaranteed that no other
            <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans"/> interface is in use and that any further request for
            such an interface no matter whether exclusive or cooperative will be
            rejected. If non-exclusive access is requested it will not be
            satisfied if an exclusive access is already granted.
            </para>
            </summary>
            <param name="exclusiveAccess">request for exclusive access(true) or cooperative access (false)</param>
            <returns>The <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans"/> interface being capable to receive user commands.</returns>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl.InstrumentValues">
            <summary>
            Get access to the instrument values that can be accessed individually.
            The returned instance is helpful for status control and direct value
            manipulation.
            <para>
            A synchroneous change of several scan-related elements should better
            be performed using <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl.GetScans(System.Boolean)"/>.
            </para>
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl.Methods">
            <summary>
            Get access to the method interface. The interface should be used
            for method-based data acquisition and for method-based information
            access.
            <para>
            This property is accessible offline.
            </para>
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl.Acquisition">
            <summary>
            Get access to the acquisition interface.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.ITableRow">
            <summary>
            A table item allows to set and retrieve column values of one row in a table.
            <para>
            A table item created for one table type cannot be used in another table of a different type.
            </para>
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.ITableRow.ColumnValues">
            <summary>
            Get access to the set of cell data store values.
            <para>
            It is not possible to add keys for unknown columns. On assignment using
            IDictionary.Add or the indexer, values will be tested for range conformance.
            </para>
            <para>
            Requesting values with the indexer will return the default value of a
            column if the cell hasn't been assigned already. Use ContainsKey or
            TryGetValue to test for assigned values.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IForcedStandbyMode">
            <summary>
            This mode lets an instrument enter the Standby state. The request will be honoured even if the
            instrument is within an acquisition or another state where it is usually better to continue.
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IForcedOffMode"/>.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition"/> for an example how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.CreateForcedStandbyMode"/>.
            </para>
            </remarks>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.NamespaceDoc">
            <summary>
            This namespace covers the various modes which can be assumed by the instrument such as On, Off, Standby.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode">
            <summary>
            This enumeration returns the overall system mode the instrument currently is in.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition"/> for an example how this enumeration can be used.
            </remarks>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.Malconfigured">
            <summary>
            The instrument description within the PC does not allow a proper connection to the instrument.
            This is a very rare condition.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.Disconnected">
            <summary>
            The instrument is not connected to the service or the current program is not connected.
            This state is also entered when the instrument reboots.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.On">
            <summary>
            The instrument is on. Other values in <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IState"/> show if an acquisition is ongoing.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.Standby">
            <summary>
            The instrument is on standby and ready for another operation mode.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.Off">
            <summary>
            The instrument is off and may need some time for perfect operation if it is set to on.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.RemoteControl">
            <summary>
            The instrument is under remote control, usually by a program of Thermo Fisher.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.DirectControl">
            <summary>
            The instrument is under direct control, usually by a user or GUI program.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.Maintenance">
            <summary>
            The instrument or its driver entered the maintenance mode.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.Calibration">
            <summary>
            The instrument performs a calibration.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.Evaluation">
            <summary>
            A system evaluation is pending.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.Bakeout">
            <summary>
            The instrument performs a bakeout.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.AutoTune">
            <summary>
            The instrument is optimizing its internal system parameters.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.CalibrationPaused">
            <summary>
            The instrument performs a calibration, but the operation pauses.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.EvaluationPaused">
            <summary>
            A system evaluation is pending, but the evaluation pauses.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.BakeoutPaused">
            <summary>
            The instrument performs a bakeout, but that operation pauses.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.AutoTunePaused">
            <summary>
            The instrument is optimizing its internal system parameters, but the process pauses.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.SystemMode.DirectControlPaused">
            <summary>
            The instrument is under direct control and acquires data, but storing data has been paused.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IOffMode">
            <summary>
            This mode lets an instrument enter the Off state. The request may be rejected if the instrument
            is in a state that should not be disturbed. See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IForcedOffMode"/>.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition"/> for an example how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.CreateOffMode"/>.
            </para>
            </remarks>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState">
            <summary>
            This enumeration defines the instrument state during an acquisition. The enumeration
            is the so called DeviceStatus of Thermo Fisher virtual instruments.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition"/> for an example how this enumeration can be used.
            </remarks>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.Initializing">
            <summary>
            "Initializing"<br/>
            Set during boot up or initialization of an acquisition service.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.ReadyToDownload">
            <summary>
            "Ready to Download"<br/>
            The instrument is ready to load a method, but any other mode is also possible.
            <para>This state will be used even in case of power saving.</para>
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.Downloading">
            <summary>
            "Downloading"<br/>
            The instrument downloads a method.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.PreparingForRun">
            <summary>
            "Preparing for Run"<br/>
            After method downloading the instrument sets up everything to start immediately without
            actually starting.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.ReadyForRun">
            <summary>
            "Ready for Run"<br/>
            The instrument is ready to run, but it still awaits the go.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.WaitingForContactClosure">
            <summary>
            "Waiting for contact closure"<br/>
            The instrument has been started but waits for a contact closure or another trigger.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.Running">
            <summary>
            "Running"<br/>
            The instrument acquires data. The instrument closes the data file before it leaves this state.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.PostRun">
            <summary>
            "Post Run"<br/>
            The instrument is doing some post cleanup.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.Error">
            <summary>
            "Error"<br/>
            The instrument entered an error condition. The user must start the instrument setup
            program to resolve the error.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.Busy">
            <summary>
            "Busy"<br/>
            The instrument is busy somehow, usually due to a maintenance operation.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.NotConnected">
            <summary>
            "Not Connected"<br/>
            The instrument software has lost the connection to the instrument.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.StandBy">
            <summary>
            "Stand By"<br/>
            From the standby state it should take a very short time to be able to continue
            work.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.Off">
            <summary>
            "Off"<br/>
            As much hardware as possible is turned off by software. Some amount of time should be expected so that
            operation can be performed with best precision.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.ServerFailed">
            <summary>
            "Not Connected" in Xcalibur's run manager.<br/>
            There exists no connection to the service keeping the connection to the instrument.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.LampWarmup">
            <summary>
            "Lamp Warmup"<br/>
            Typically used by UV devices to indicate when they are waiting for their lamp to become ready.
            This may include lamps of the APPI source.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.NotReady">
            <summary>
            "Not Ready"<br/>
            The instrument is not  ready to perform any operation.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.InstrumentState.DirectControl">
            <summary>
            "Direct Control"<br/>
            The device is under direct control of a user or GUI program.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTracePoint">
            <summary>
            An IAnalogTracePoint describes a value of an analog detector.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTraceContainer"/> for an example how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTraceContainer.LastValue"/> or by
            <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.AnalogTracePointEventArgs.TracePoint"/>.
            </para>
            </remarks>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTracePoint.Value">
            <summary>
            The value of the analog detector.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.IAnalogTracePoint.Occurrence">
            <summary>
            The time difference between acquisition start and the arrival of the analog value.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.NamespaceDoc">
            <summary>
            This namespace covers the direct control functionality that a user may have to manage an instrument.
            Such a control is not permitted all the time for each Value/Readback and allows 
            the change of values individually.
            <para>
            The use of this namespace should be avoided if individual scans should be placed. Better use
            the <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.IScans"/> interface instead.
            </para>
            <para>
            Obtain <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl"/>.<see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl.InstrumentValues"/>
            to create the desired base class.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsAcquisitionOpeningEventArgs">
            <summary>
            This implementation of EventArgs carries information about further
            <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan"/>s to be acquired.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer"/> for an example how this class can be used.
            <para>
            An instance of this class will be created by <see cref="E:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer.AcquisitionStreamOpening"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsAcquisitionOpeningEventArgs.#ctor">
            <summary>
            Create a new <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsAcquisitionOpeningEventArgs"/>.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsAcquisitionOpeningEventArgs.SpecificInformation">
            <summary>
            Get access to the information being specific to this instrument class or acquisition type.
            Number will be presented in US locale, default values may be omitted.
            The dictionary is read-only.
            <para>
            The information is very similar to that of a scan but covers only those information
            that is available before a scan has been acquired.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.IContent">
            <summary>
            A value content describes the content of an <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.IReadback"/> or <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IValue"/> representation
            of the instrument.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.InstrumentValues.IInstrumentValues"/> or <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition"/> for examples how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IReadback.Content"/> or by
            <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.ContentChangedEventArgs.Content"/>.
            </para>
            </remarks>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IContent.Content">
            <summary>
            The current content of the instrument's value representation. Every content is a string,
            a numerical content will be encoded according to en-US rules.
            <para>
            The content will be null if the instrument is not connected or if the IReadback is unknown
            to the instrument.
            </para>
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IContent.Unit">
            <summary>
            The unit of the <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IContent.Content"/> is the empty string in most cases, value of the
            instrument's value representation. All values are strings,
            numerical values will be encoded according to en-US rules.
            <para>
            The unit will be null if the instrument is not connected or if the IReadback is unknown
            to the instrument.
            </para>
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IContent.Status">
            <summary>
            The status of a value will be 0 for OK, 1 if the value represents an information,
            2 describes a warning, 3 an error and 4 a fatal error. The value will be -1 if the
            status is unknown.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IContent.Help">
            <summary>
            The help string may be set only in some cases and gives a brief description of this Value.
            <para>
            The help will be null if the information is not present due to various reasons.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IStandbyMode">
            <summary>
            This mode lets an instrument enter the Standby state. The request may be rejected if the instrument
            is in a state that should not be disturbed. See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.Modes.IForcedStandbyMode"/>.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition"/> for an example how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.Acquisition.IAcquisition.CreateStandbyMode"/>.
            </para>
            </remarks>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsScanEventArgs">
            <summary>
            This implementation of EventArgs carries an <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan"/>.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer"/> for an example how this class can be used.
            <para>
            An instance of this class will be created by <see cref="E:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer.MsScanArrived"/>.
            </para>
            </remarks>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsScanEventArgs.#ctor">
            <summary>
            Create a new <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsScanEventArgs"/>.
            </summary>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsScanEventArgs.GetScan">
            <summary>
            Get the scan that has just arrived from the instrument.
            It has replaced already the LastScan in the <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer"/>.
            <para>
            Note that accessing this method forces the consumer to dispose
            the item as soon as possible in order to free its shared memory resources.
            </para>
            </summary>
            <returns>The method returns the scan data of a scan event. It is castable to an Thermo.Interfaces.InstrumentAccess_V2.MsScanContainer.IMsScan</returns>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.ErrorsArrivedEventArgs">
             <summary>
             This implementation of EventArgs carries a list of <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.IError"/>s.
             This class will not be used for status reports or messages of the
             transport layer.
             </summary>
             <remarks>
             An instance of this class will be created by <see cref="E:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess.ErrorsArrived"/>.
             </remarks>
             <example>
             This example shows how to use this class. The removal of the handler is not shown.
             <code>
             /// &lt;summary&gt;
             /// Set up all the instrument.
             /// &lt;/summary&gt;
             /// &lt;param name="instrument"&gt;instrument for which errors shall be logged&lt;/param&gt;
             void Init(IInstrumentAccess instrument)
             {
            	    InstrumentInstance.ErrorsArrived += new EventHandler&lt;ErrorsArrivedEventArgs&gt;(Instrument_ErrorsArrived);
             }
            
             /// &lt;summary&gt;
             /// When errors from the instrument arrived we publish them.
             /// &lt;/summary&gt;
             /// &lt;param name="sender"&gt;doesn't matter&lt;/param&gt;
             /// &lt;param name="e"&gt;contains the messages to be dumped&lt;/param&gt;
             private void Instrument_ErrorsArrived(object sender, ErrorsArrivedEventArgs e)
             {
            	    foreach (IError error in e.Errors)
            	    {
            	        Console.WriteLine("ERROR&gt;&gt;&gt; " + error.Content);
            	    }
             }
             </code>
             </example>
        </member>
        <member name="M:Thermo.Interfaces.InstrumentAccess_V1.ErrorsArrivedEventArgs.#ctor">
            <summary>
            Create a new <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.ErrorsArrivedEventArgs"/>.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.ErrorsArrivedEventArgs.Errors">
            <summary>
            Get access to the errors that have arrived from the instrument.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Scans.NamespaceDoc">
            <summary>
            This namespace covers the functionality that a user needs to place invididual scans or repeating scans
            that are not part of a method.
            <para>
            Obtain <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl"/>.<see cref="M:Thermo.Interfaces.InstrumentAccess_V1.Control.IControl.GetScans(System.Boolean)"/>
            to create the desired base class.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.NamespaceDoc">
            <summary>
            This namespace covers the control functionality that a user may have to manage an instrument.
            Not all interfaces need to be implemented by a particular instrument.
            <para>
            Obtain <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess"/>.<see cref="P:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess.Control"/>
            to create the desired base class.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.AnalogTraceContainer.NamespaceDoc">
            <summary>
            This namespace covers those interfaces for sole use by analog trace devices.
            Such devices are PDAs, UVs, etc.
            <para>
            Call <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess"/>.<see cref="M:Thermo.Interfaces.InstrumentAccess_V1.IInstrumentAccess.GetAnalogTraceContainer(System.Int32)"/>
            to create the desired base class.
            </para>
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.INoiseNode">
            <summary>
            One noise node is part of a set of noise nodes which describe the individual noise
            by interpolation at a specific point. Each noise node should be combined with its
            neightbors in a polygonial way.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer"/> for an example how this interface can be used.
            <para>
            An instance of this class will be created by <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScan.NoiseBand"/>.
            </para>
            </remarks>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.INoiseNode.Baseline">
            <summary>
            Baseline of the noise node. The value will be null if no baseline is available.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsScanInformationSource">
            <summary>
            The enum describes where an information comes from in an <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IInfoContainer"/>.
            </summary>
            <remarks>
            See <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.IMsScanContainer"/> for an example how this enumeration can be used.
            </remarks>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsScanInformationSource.Unknown">
            <summary>
            The source is unknown or does not matter. When requesting information
            this value will let the interface search the following sources in the
            numerical order.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsScanInformationSource.Common">
            <summary>
            The common parameter set is that that will be used by all Thermo instruments
            if the information is known to all all instruments. Such information
            covers polarity, etc.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsScanInformationSource.Trailer">
            <summary>
            The Trailer data source covers values which are very specific to the instrument
            and which change or may change on a scan by scan bysis.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsScanInformationSource.Status">
            <summary>
            The Status data source covers values which represents status values like
            detector temperatures, etc. In opposite to the <see cref="F:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsScanInformationSource.Trailer"/> this
            information may not be updated scan by scan. The information might be
            buffered.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsScanInformationSource.TuneData">
            <summary>
            The TuneData source covers values taken from the tune file if the instrument
            uses such techniques. The information may be buffered because tune files
            will not change frequently.
            </summary>
        </member>
        <member name="F:Thermo.Interfaces.InstrumentAccess_V1.MsScanContainer.MsScanInformationSource.AcquisitionFixed">
            <summary>
            The AcquisitionFixed source covers values present since the start of the
            acquisition.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.ITableColumnDescription">
            <summary>
            This interface allows one to retrieve information about a column of an <see cref="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.ITable"/>.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.ITableColumnDescription.Optional">
            <summary>
            Returns whether the column is optional.
            </summary>
        </member>
        <member name="P:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.ITableColumnDescription.AcceptedHeaderNames">
            <summary>
            Get all alternate names to the header of the column. The standard name is returned in <see cref="P:Thermo.Interfaces.InstrumentAccess_V1.Control.IParameterDescription.Name"/>.
            </summary>
        </member>
        <member name="T:Thermo.Interfaces.InstrumentAccess_V1.Control.Methods.IExclusionTable">
            <summary>
            This flag interface defines a table which carries exclusion items.
            </summary>
        </member>
    </members>
</doc>

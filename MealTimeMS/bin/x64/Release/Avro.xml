<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Avro</name>
    </assembly>
    <members>
        <member name="T:Avro.AvroDecimal">
            <summary>
            Represents a big decimal.
            </summary>
        </member>
        <member name="M:Avro.AvroDecimal.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroDecimal"/> class from a given double.
            </summary>
            <param name="value">The double value.</param>
        </member>
        <member name="M:Avro.AvroDecimal.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroDecimal"/> class from a given float.
            </summary>
            <param name="value">The float value.</param>
        </member>
        <member name="M:Avro.AvroDecimal.#ctor(System.Decimal)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroDecimal"/> class from a given decimal.
            </summary>
            <param name="value">The decimal value.</param>
        </member>
        <member name="M:Avro.AvroDecimal.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroDecimal"/> class from a given int.
            </summary>
            <param name="value">The int value.</param>
        </member>
        <member name="M:Avro.AvroDecimal.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroDecimal"/> class from a given long.
            </summary>
            <param name="value">The long value.</param>
        </member>
        <member name="M:Avro.AvroDecimal.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroDecimal"/> class from a given unsigned int.
            </summary>
            <param name="value">The unsigned int value.</param>
        </member>
        <member name="M:Avro.AvroDecimal.#ctor(System.UInt64)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroDecimal"/> class from a given unsigned long.
            </summary>
            <param name="value">The unsigned long value.</param>
        </member>
        <member name="M:Avro.AvroDecimal.#ctor(System.Numerics.BigInteger,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroDecimal"/> class from a given <see cref="T:System.Numerics.BigInteger"/>
            and a scale.
            </summary>
            <param name="unscaledValue">The double value.</param>
            <param name="scale">The scale.</param>
        </member>
        <member name="P:Avro.AvroDecimal.UnscaledValue">
            <summary>
            Gets the unscaled integer value represented by the current <see cref="T:Avro.AvroDecimal"/>.
            </summary>
        </member>
        <member name="P:Avro.AvroDecimal.Scale">
            <summary>
            Gets the scale of the current <see cref="T:Avro.AvroDecimal"/>.
            </summary>
        </member>
        <member name="P:Avro.AvroDecimal.Sign">
            <summary>
            Gets the sign of the current <see cref="T:Avro.AvroDecimal"/>.
            </summary>
        </member>
        <member name="M:Avro.AvroDecimal.ToString">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to a string.
            </summary>
            <returns>A string representation of the numeric value.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.ToByte(Avro.AvroDecimal)">
            <summary>
            Creates a byte from a given <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <param name="value">The <see cref="T:Avro.AvroDecimal"/>.</param>
            <returns>A byte.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.ToSByte(Avro.AvroDecimal)">
            <summary>
            Creates a signed byte from a given <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <param name="value">The <see cref="T:Avro.AvroDecimal"/>.</param>
            <returns>A signed byte.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.ToInt16(Avro.AvroDecimal)">
            <summary>
            Creates a short from a given <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <param name="value">The <see cref="T:Avro.AvroDecimal"/>.</param>
            <returns>A short.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.ToInt32(Avro.AvroDecimal)">
            <summary>
            Creates an int from a given <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <param name="value">The <see cref="T:Avro.AvroDecimal"/>.</param>
            <returns>An int.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.ToInt64(Avro.AvroDecimal)">
            <summary>
            Creates a long from a given <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <param name="value">The <see cref="T:Avro.AvroDecimal"/>.</param>
            <returns>A long.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.ToUInt16(Avro.AvroDecimal)">
            <summary>
            Creates an unsigned short from a given <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <param name="value">The <see cref="T:Avro.AvroDecimal"/>.</param>
            <returns>An unsigned short.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.ToUInt32(Avro.AvroDecimal)">
            <summary>
            Creates an unsigned int from a given <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <param name="value">The <see cref="T:Avro.AvroDecimal"/>.</param>
            <returns>An unsigned int.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.ToUInt64(Avro.AvroDecimal)">
            <summary>
            Creates an unsigned long from a given <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <param name="value">The <see cref="T:Avro.AvroDecimal"/>.</param>
            <returns>An unsigned long.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.ToSingle(Avro.AvroDecimal)">
            <summary>
            Creates a double from a given <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <param name="value">The <see cref="T:Avro.AvroDecimal"/>.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.ToDouble(Avro.AvroDecimal)">
            <summary>
            Creates a double from a given <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <param name="value">The <see cref="T:Avro.AvroDecimal"/>.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.ToDecimal(Avro.AvroDecimal)">
            <summary>
            Creates a decimal from a given <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <param name="value">The <see cref="T:Avro.AvroDecimal"/>.</param>
            <returns>A decimal.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.ToBigInteger(Avro.AvroDecimal)">
            <summary>
            Creates a <see cref="T:System.Numerics.BigInteger"/> from a given <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <param name="value">The <see cref="T:Avro.AvroDecimal"/>.</param>
            <returns>A <see cref="T:System.Numerics.BigInteger"/>.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.ToType``1">
            <summary>
            Converts the numeric value of the current <see cref="T:Avro.AvroDecimal"/> to a given type.
            </summary>
            <typeparam name="T">The type to which the value of the current <see cref="T:Avro.AvroDecimal"/> should be converted.</typeparam>
            <returns>A value of type <typeparamref name="T"/> converted from the current <see cref="T:Avro.AvroDecimal"/>.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
            <summary>
            Converts the numeric value of the current <see cref="T:Avro.AvroDecimal"/> to a given type.
            </summary>
            <param name="conversionType">The type to which the value of the current <see cref="T:Avro.AvroDecimal"/> should be converted.</param>
            <param name="provider">An System.IFormatProvider interface implementation that supplies culture-specific formatting information.</param>
            <returns></returns>
        </member>
        <member name="M:Avro.AvroDecimal.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Avro.AvroDecimal"/> and a specified object
            have the same value.
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>true if the obj argument is an <see cref="T:Avro.AvroDecimal"/> object, and its value
            is equal to the value of the current <see cref="T:Avro.AvroDecimal"/> instance; otherwise false.
            </returns>
        </member>
        <member name="M:Avro.AvroDecimal.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#GetTypeCode">
            <summary>
            Returns the <see cref="T:System.TypeCode"/> for the current <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <returns><see cref="F:System.TypeCode.Object"/>.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToBoolean(System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to a boolean.
            </summary>
            <param name="provider">The format provider.</param>
            <returns>true or false, which reflects the value of the current <see cref="T:Avro.AvroDecimal"/>.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToByte(System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to a byte.
            </summary>
            <param name="provider">The format provider.</param>
            <returns>A byte.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToChar(System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to a char.
            </summary>
            <param name="provider">The format provider.</param>
            <returns>This method always throws an <see cref="T:System.InvalidCastException"/>.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToDateTime(System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to a <see cref="T:System.DateTime"/>.
            </summary>
            <param name="provider">The format provider.</param>
            <returns>This method always throws an <see cref="T:System.InvalidCastException"/>.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToDecimal(System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to a decimal.
            </summary>
            <param name="provider">The format provider.</param>
            <returns>A decimal.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToDouble(System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to a double.
            </summary>
            <param name="provider">The format provider.</param>
            <returns>A double.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToInt16(System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to a short.
            </summary>
            <param name="provider">The format provider.</param>
            <returns>A short.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToInt32(System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to an int.
            </summary>
            <param name="provider">The format provider.</param>
            <returns>An int.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToInt64(System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to a long.
            </summary>
            <param name="provider">The format provider.</param>
            <returns>A long.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToSByte(System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to a signed byte.
            </summary>
            <param name="provider">The format provider.</param>
            <returns>A signed byte.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToSingle(System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to a float.
            </summary>
            <param name="provider">The format provider.</param>
            <returns>A float.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToString(System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to a string.
            </summary>
            <param name="provider">The format provider.</param>
            <returns>A string.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToUInt16(System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to an unsigned short.
            </summary>
            <param name="provider">The format provider.</param>
            <returns>An unsigned short.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToUInt32(System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to an unsigned int.
            </summary>
            <param name="provider">The format provider.</param>
            <returns>An unsigned int.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.System#IConvertible#ToUInt64(System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to an unsigned long.
            </summary>
            <param name="provider">The format provider.</param>
            <returns>An unsigned long.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.ToString(System.String,System.IFormatProvider)">
            <summary>
            Converts the current <see cref="T:Avro.AvroDecimal"/> to a string.
            </summary>
            <param name="format"></param>
            <param name="formatProvider">The format provider.</param>
            <returns>A string representation of the numeric value.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.CompareTo(System.Object)">
            <summary>
            Compares the value of the current <see cref="T:Avro.AvroDecimal"/> to the value of another object.
            </summary>
            <param name="obj">The object to compare.</param>
            <returns>A value that indicates the relative order of the objects being compared.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.CompareTo(Avro.AvroDecimal)">
            <summary>
            Compares the value of the current <see cref="T:Avro.AvroDecimal"/> to the value of another
            <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <param name="other">The <see cref="T:Avro.AvroDecimal"/> to compare.</param>
            <returns>A value that indicates the relative order of the <see cref="T:Avro.AvroDecimal"/>
            instances being compared.</returns>
        </member>
        <member name="M:Avro.AvroDecimal.Equals(Avro.AvroDecimal)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:Avro.AvroDecimal"/> has the same
            value as another <see cref="T:Avro.AvroDecimal"/>.
            </summary>
            <param name="other">The <see cref="T:Avro.AvroDecimal"/> to compare.</param>
            <returns>true if the current <see cref="T:Avro.AvroDecimal"/> has the same value as <paramref name="other"/>;
            otherwise false.</returns>
        </member>
        <member name="T:Avro.AvroRuntimeException">
            <summary>
            A generic Avro exception.
            </summary>
        </member>
        <member name="M:Avro.AvroRuntimeException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroRuntimeException"/> class.
            </summary>
        </member>
        <member name="M:Avro.AvroRuntimeException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroRuntimeException"/> class.
            </summary>
            <param name="s">The message that describes the error.</param>
        </member>
        <member name="M:Avro.AvroRuntimeException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroRuntimeException"/> class.
            </summary>
            <param name="s">The message that describes the error.</param>
            <param name="inner">
            The exception that is the cause of the current exception, or a null reference
            if no inner exception is specified.
            </param>
        </member>
        <member name="T:Avro.CodeGen">
            <summary>
            Generates C# code from Avro schemas and protocols.
            </summary>
        </member>
        <member name="P:Avro.CodeGen.CompileUnit">
            <summary>
            Object that contains all the generated types
            </summary>
        </member>
        <member name="P:Avro.CodeGen.Schemas">
            <summary>
            List of schemas to generate code for
            </summary>
        </member>
        <member name="P:Avro.CodeGen.Protocols">
            <summary>
            List of protocols to generate code for
            </summary>
        </member>
        <member name="P:Avro.CodeGen.NamespaceMapping">
            <summary>
            Mapping of Avro namespaces to C# namespaces
            </summary>
        </member>
        <member name="F:Avro.CodeGen.namespaceLookup">
            <summary>
            List of generated namespaces
            </summary>
        </member>
        <member name="P:Avro.CodeGen.NamespaceLookup">
            <summary>
            List of generated namespaces.
            </summary>
        </member>
        <member name="M:Avro.CodeGen.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Avro.CodeGen.AddProtocol(Avro.Protocol)">
            <summary>
            Adds a protocol object to generate code for
            </summary>
            <param name="protocol">protocol object</param>
        </member>
        <member name="M:Avro.CodeGen.AddSchema(Avro.Schema)">
            <summary>
            Adds a schema object to generate code for
            </summary>
            <param name="schema">schema object</param>
        </member>
        <member name="M:Avro.CodeGen.addNamespace(System.String)">
            <summary>
            Adds a namespace object for the given name into the dictionary if it doesn't exist yet
            </summary>
            <param name="name">name of namespace</param>
            <returns></returns>
        </member>
        <member name="M:Avro.CodeGen.GenerateCode">
            <summary>
            Generates code for the given protocol and schema objects
            </summary>
            <returns>CodeCompileUnit object</returns>
        </member>
        <member name="M:Avro.CodeGen.processSchemas">
            <summary>
            Generates code for the schema objects
            </summary>
        </member>
        <member name="M:Avro.CodeGen.processProtocols">
            <summary>
            Generates code for the protocol objects
            </summary>
        </member>
        <member name="M:Avro.CodeGen.generateNames(Avro.Protocol)">
            <summary>
            Generate list of named schemas from given protocol
            </summary>
            <param name="protocol">protocol to process</param>
            <returns></returns>
        </member>
        <member name="M:Avro.CodeGen.generateNames(Avro.Schema)">
            <summary>
            Generate list of named schemas from given schema
            </summary>
            <param name="schema">schema to process</param>
            <returns></returns>
        </member>
        <member name="M:Avro.CodeGen.addName(Avro.Schema,Avro.SchemaNames)">
            <summary>
            Recursively search the given schema for named schemas and adds them to the given container
            </summary>
            <param name="schema">schema object to search</param>
            <param name="names">list of named schemas</param>
        </member>
        <member name="M:Avro.CodeGen.processFixed(Avro.Schema)">
            <summary>
            Creates a class declaration for fixed schema
            </summary>
            <param name="schema">fixed schema</param>
        </member>
        <member name="M:Avro.CodeGen.processEnum(Avro.Schema)">
            <summary>
            Creates an enum declaration
            </summary>
            <param name="schema">enum schema</param>
        </member>
        <member name="M:Avro.CodeGen.processInterface(Avro.Protocol)">
            <summary>
            Generates code for an individual protocol.
            </summary>
            <param name="protocol">Protocol to generate code for.</param>
        </member>
        <member name="M:Avro.CodeGen.processRecord(Avro.Schema)">
            <summary>
            Creates a class declaration
            </summary>
            <param name="schema">record schema</param>
            <returns>A new class code type declaration</returns>
        </member>
        <member name="M:Avro.CodeGen.getType(Avro.Schema,System.Boolean,System.Boolean@)">
            <summary>
            Gets the string representation of the schema's data type
            </summary>
            <param name="schema">schema</param>
            <param name="nullible">flag to indicate union with null</param>
            <param name="nullibleEnum">
            This method sets this value to indicate whether the enum is nullable. True indicates
            that it is nullable. False indicates that it is not nullable.
            </param>
            <returns>Name of the schema's C# type representation.</returns>
        </member>
        <member name="M:Avro.CodeGen.getNullableType(Avro.UnionSchema)">
            <summary>
            Gets the schema of a union with null
            </summary>
            <param name="schema">union schema</param>
            <returns>schema that is nullible</returns>
        </member>
        <member name="M:Avro.CodeGen.createSchemaField(Avro.Schema,System.CodeDom.CodeTypeDeclaration,System.Boolean)">
            <summary>
            Creates the static schema field for class types
            </summary>
            <param name="schema">schema</param>
            <param name="ctd">CodeTypeDeclaration for the class</param>
            <param name="overrideFlag">
            Indicates whether we should add the <see cref="F:System.CodeDom.MemberAttributes.Override"/> to the
            generated property.
            </param>
        </member>
        <member name="M:Avro.CodeGen.createDocComment(System.String)">
            <summary>
            Creates an XML documentation for the given comment
            </summary>
            <param name="comment">comment</param>
            <returns>CodeCommentStatement object</returns>
        </member>
        <member name="M:Avro.CodeGen.WriteCompileUnit(System.String)">
            <summary>
            Writes the generated compile unit into one file
            </summary>
            <param name="outputFile">name of output file to write to</param>
        </member>
        <member name="M:Avro.CodeGen.WriteTypes(System.String)">
            <summary>
            Writes each types in each namespaces into individual files
            </summary>
            <param name="outputdir">name of directory to write to</param>
        </member>
        <member name="T:Avro.CodeGenUtil">
            <summary>
            A singleton class containing data used by codegen
            </summary>
        </member>
        <member name="P:Avro.CodeGenUtil.Instance">
            <summary>
            Singleton instance of this class.
            </summary>
        </member>
        <member name="P:Avro.CodeGenUtil.NamespaceImports">
            <summary>
            Namespaces to import in generated code.
            </summary>
        </member>
        <member name="P:Avro.CodeGenUtil.FileComment">
            <summary>
            Comment included at the top of each generated code file.
            </summary>
        </member>
        <member name="P:Avro.CodeGenUtil.ReservedKeywords">
            <summary>
            Reserved keywords in the C# language.
            </summary>
        </member>
        <member name="F:Avro.CodeGenUtil.Object">
            <summary>
            Fully-qualified name of a <see cref="F:Avro.CodeGenUtil.Object"/> type.
            </summary>
        </member>
        <member name="M:Avro.CodeGenUtil.Mangle(System.String)">
            <summary>
            Append @ to all reserved keywords that appear on the given name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.CodeGenUtil.UnMangle(System.String)">
            <summary>
            Remove all the @
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:Avro.File.Codec">
            <summary>
            Base class for Avro-supported compression codecs for data files. Note that Codec objects may
            maintain internal state (e.g. buffers) and are not thread safe.
            </summary>
        </member>
        <member name="M:Avro.File.Codec.Compress(System.Byte[])">
            <summary>
            Compress data using implemented codec
            </summary>
            <param name="uncompressedData"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.File.Codec.Compress(System.IO.MemoryStream,System.IO.MemoryStream)">
            <summary>
            Compress data using implemented codec
            </summary>
            <param name="inputStream">The stream which contains the data to be compressed</param>
            <param name="outputStream">A reusable stream which will hold the compressed data. That stream should be empty.</param>
        </member>
        <member name="M:Avro.File.Codec.Decompress(System.Byte[])">
            <summary>
            Decompress data using implemented codec
            </summary>
            <param name="compressedData"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.File.Codec.GetName">
            <summary>
            Name of this codec type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.File.Codec.Equals(System.Object)">
            <summary>
             Codecs must implement an equals() method
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.File.Codec.GetHashCode">
            <summary>
            Codecs must implement a HashCode() method that is
            consistent with Equals
            </summary>
            <returns></returns>
        </member>
        <member name="T:Avro.File.Codec.Type">
            <summary>
            Codec types
            </summary>
        </member>
        <member name="F:Avro.File.Codec.Type.Deflate">
            <summary>
            Codec type that implments the "deflate" compression algorithm.
            </summary>
        </member>
        <member name="F:Avro.File.Codec.Type.Null">
            <summary>
            Codec that does not perform any compression.
            </summary>
        </member>
        <member name="M:Avro.File.Codec.CreateCodec(Avro.File.Codec.Type)">
            <summary>
            Factory method to return child
            codec instance based on Codec.Type
            </summary>
            <param name="codecType"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.File.Codec.CreateCodecFromString(System.String)">
            <summary>
            Factory method to return child
            codec instance based on string type
            </summary>
            <param name="codecType"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.File.Codec.ToString">
            <summary>
            Returns name of codec
            </summary>
            <returns></returns>
        </member>
        <member name="T:Avro.File.DataBlock">
            <summary>
            Encapsulates a block of data read by the <see cref="T:Avro.File.DataFileReader`1"/>.
            We will remove this class from the public API in a future version because it is only meant
            to be used internally.
            </summary>
        </member>
        <member name="P:Avro.File.DataBlock.Data">
            <summary>
            Raw bytes within this block.
            </summary>
        </member>
        <member name="P:Avro.File.DataBlock.NumberOfEntries">
            <summary>
            Number of entries in this block.
            </summary>
        </member>
        <member name="P:Avro.File.DataBlock.BlockSize">
            <summary>
            Size of this block in bytes.
            </summary>
        </member>
        <member name="M:Avro.File.DataBlock.#ctor(System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.File.DataBlock"/> class.
            </summary>
            <param name="numberOfEntries">Number of entries in this block.</param>
            <param name="blockSize">Size of this block in bytes.</param>
        </member>
        <member name="T:Avro.File.DataFileConstants">
            <summary>
            Constants used in data files.
            </summary>
        </member>
        <member name="F:Avro.File.DataFileConstants.MetaDataSync">
            <summary>
            Key for the 'sync' metadata entry.
            </summary>
        </member>
        <member name="F:Avro.File.DataFileConstants.MetaDataCodec">
            <summary>
            Key for the 'codec' metadata entry.
            </summary>
        </member>
        <member name="F:Avro.File.DataFileConstants.MetaDataSchema">
            <summary>
            Key for the 'schema' metadata entry.
            </summary>
        </member>
        <member name="F:Avro.File.DataFileConstants.NullCodec">
            <summary>
            Identifier for the null codec.
            </summary>
        </member>
        <member name="F:Avro.File.DataFileConstants.DeflateCodec">
            <summary>
            Identifier for the deflate codec.
            </summary>
        </member>
        <member name="F:Avro.File.DataFileConstants.MetaDataReserved">
            <summary>
            Reserved 'avro' metadata key.
            </summary>
        </member>
        <member name="F:Avro.File.DataFileConstants.Version">
            <summary>
            Avro specification version.
            </summary>
        </member>
        <member name="F:Avro.File.DataFileConstants.Magic">
            <summary>
            Magic bytes at the beginning of an Avro data file.
            </summary>
        </member>
        <member name="F:Avro.File.DataFileConstants.NullCodecHash">
            <summary>
            Hash code for the null codec.
            </summary>
            <seealso cref="M:Avro.File.NullCodec.GetHashCode"/>
        </member>
        <member name="F:Avro.File.DataFileConstants.DeflateCodecHash">
            <summary>
            Hash code for the deflate codec.
            </summary>
            <seealso cref="M:Avro.File.DeflateCodec.GetHashCode"/>
        </member>
        <member name="F:Avro.File.DataFileConstants.SyncSize">
            <summary>
            Size of a sync token in bytes.
            </summary>
        </member>
        <member name="F:Avro.File.DataFileConstants.DefaultSyncInterval">
            <summary>
            Default interval for sync tokens.
            </summary>
        </member>
        <member name="T:Avro.File.DataFileReader`1">
            <summary>
            Provides access to Avro data written using the <see cref="T:Avro.File.DataFileWriter`1"/>.
            </summary>
            <typeparam name="T">Type to deserialze data objects to.</typeparam>
        </member>
        <member name="T:Avro.File.DataFileReader`1.CreateDatumReader">
            <summary>
            Defines the signature for a function that returns a new <see cref="T:Avro.Generic.DatumReader`1"/>
            given a writer and reader schema.
            </summary>
            <param name="writerSchema">Schema used to write the datum.</param>
            <param name="readerSchema">Schema used to read the datum.</param>
            <returns>A datum reader.</returns>
        </member>
        <member name="M:Avro.File.DataFileReader`1.OpenReader(System.String)">
            <summary>
             Open a reader for a file using path
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.File.DataFileReader`1.OpenReader(System.String,Avro.Schema)">
            <summary>
             Open a reader for a file using path and the reader's schema
            </summary>
            <param name="path">Path to the file</param>
            <param name="readerSchema">Schema used to read data from the file</param>
            <returns>A new file reader</returns>
        </member>
        <member name="M:Avro.File.DataFileReader`1.OpenReader(System.IO.Stream)">
            <summary>
             Open a reader for a stream
            </summary>
            <param name="inStream"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.File.DataFileReader`1.OpenReader(System.IO.Stream,System.Boolean)">
            <summary>
             Open a reader for a stream
            </summary>
            <param name="inStream"></param>
            <param name="leaveOpen">Leave the stream open after disposing the object</param>
            <returns></returns>
        </member>
        <member name="M:Avro.File.DataFileReader`1.OpenReader(System.IO.Stream,Avro.Schema)">
            <summary>
            Open a reader for a stream using the reader's schema
            </summary>
            <param name="inStream">Stream containing the file contents</param>
            <param name="readerSchema">Schema used to read the file</param>
            <returns>A new file reader</returns>
        </member>
        <member name="M:Avro.File.DataFileReader`1.OpenReader(System.IO.Stream,Avro.Schema,System.Boolean)">
            <summary>
            Open a reader for a stream using the reader's schema
            </summary>
            <param name="inStream">Stream containing the file contents</param>
            <param name="readerSchema">Schema used to read the file</param>
            <param name="leaveOpen">Leave the stream open after disposing the object</param>
            <returns>A new file reader</returns>
        </member>
        <member name="M:Avro.File.DataFileReader`1.OpenReader(System.IO.Stream,Avro.Schema,Avro.File.DataFileReader{`0}.CreateDatumReader)">
            <summary>
             Open a reader for a stream using the reader's schema and a custom DatumReader
            </summary>
            <param name="inStream">Stream of file contents</param>
            <param name="readerSchema">Schema used to read the file</param>
            <param name="datumReaderFactory">Factory to create datum readers given a reader an writer schema</param>
            <returns>A new file reader</returns>
        </member>
        <member name="M:Avro.File.DataFileReader`1.OpenReader(System.IO.Stream,Avro.Schema,Avro.File.DataFileReader{`0}.CreateDatumReader,System.Boolean)">
            <summary>
             Open a reader for a stream using the reader's schema and a custom DatumReader
            </summary>
            <param name="inStream">Stream of file contents</param>
            <param name="readerSchema">Schema used to read the file</param>
            <param name="datumReaderFactory">Factory to create datum readers given a reader an writer schema</param>
            <param name="leaveOpen">Leave the stream open after disposing the object</param>
            <returns>A new file reader</returns>
        </member>
        <member name="M:Avro.File.DataFileReader`1.GetHeader">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileReader`1.GetSchema">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileReader`1.GetMetaKeys">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileReader`1.GetMeta(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileReader`1.GetMetaLong(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileReader`1.GetMetaString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileReader`1.Seek(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileReader`1.Sync(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileReader`1.PastSync(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileReader`1.PreviousSync">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileReader`1.Tell">
            <inheritdoc/>
        </member>
        <member name="P:Avro.File.DataFileReader`1.NextEntries">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileReader`1.HasNext">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileReader`1.Reset">
            <summary>
            Resets this reader.
            </summary>
        </member>
        <member name="M:Avro.File.DataFileReader`1.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileReader`1.Dispose(System.Boolean)">
            <summary>
            Releases resources associated with this <see cref="T:Avro.File.DataFileReader`1"/>.
            </summary>
            <param name="disposing">
            True if called from <see cref="M:Avro.File.DataFileReader`1.Dispose"/>; false otherwise.
            </param>
        </member>
        <member name="M:Avro.File.DataFileReader`1.Next">
            <inheritdoc/>
        </member>
        <member name="T:Avro.File.DataFileReader`1.DataBlock">
            <summary>
            Encapsulates a block of data read by the <see cref="T:Avro.File.DataFileReader`1"/>.
            </summary>
        </member>
        <member name="P:Avro.File.DataFileReader`1.DataBlock.Data">
            <summary>
            Raw bytes within this block.
            </summary>
        </member>
        <member name="P:Avro.File.DataFileReader`1.DataBlock.NumberOfEntries">
            <summary>
            Number of entries in this block.
            </summary>
        </member>
        <member name="P:Avro.File.DataFileReader`1.DataBlock.BlockSize">
            <summary>
            Size of this block in bytes.
            </summary>
        </member>
        <member name="M:Avro.File.DataFileReader`1.DataBlock.#ctor(System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.File.DataFileReader`1.DataBlock"/> class.
            </summary>
            <param name="numberOfEntries">Number of entries in this block.</param>
            <param name="blockSize">Size of this block in bytes.</param>
        </member>
        <member name="T:Avro.File.DataFileWriter`1">
            <summary>
            Stores in a file a sequence of data conforming to a schema. The schema is stored in the file
            with the data. Each datum in a file is of the same schema. Data is written with a
            <see cref="T:Avro.Generic.DatumWriter`1"/>. Data is grouped into blocks. A synchronization marker is
            written between blocks, so that files may be split. Blocks may be compressed. Extensible
            metadata is stored at the end of the file. Files may be appended to.
            </summary>
            <typeparam name="T">Type of datum to write to the file.</typeparam>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.OpenWriter(Avro.Generic.DatumWriter{`0},System.String)">
            <summary>
            Open a new writer instance to write
            to a file path, using a Null codec
            </summary>
            <param name="writer">Datum writer to use.</param>
            <param name="path">Path to the file.</param>
            <returns>A new file writer.</returns>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.OpenWriter(Avro.Generic.DatumWriter{`0},System.IO.Stream)">
            <summary>
            Open a new writer instance to write
            to an output stream, using a Null codec
            </summary>
            <param name="writer">Datum writer to use.</param>
            <param name="outStream">Stream to write to.</param>
            <returns>A new file writer.</returns>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.OpenWriter(Avro.Generic.DatumWriter{`0},System.IO.Stream,System.Boolean)">
            <summary>
            Open a new writer instance to write
            to an output stream, using a Null codec
            </summary>
            <param name="writer">Datum writer to use.</param>
            <param name="outStream">Stream to write to.</param>
            <param name="leaveOpen">Leave the stream open after disposing the object</param>
            <returns>A new file writer.</returns>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.OpenWriter(Avro.Generic.DatumWriter{`0},System.String,Avro.File.Codec)">
            <summary>
            Open a new writer instance to write
            to a file path with a specified codec
            </summary>
            <param name="writer">Datum writer to use.</param>
            <param name="path">Path to the file.</param>
            <param name="codec">Codec to use when writing.</param>
            <returns>A new file writer.</returns>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.OpenWriter(Avro.Generic.DatumWriter{`0},System.IO.Stream,Avro.File.Codec)">
            <summary>
            Open a new writer instance to write
            to an output stream with a specified codec
            </summary>
            <param name="writer">Datum writer to use.</param>
            <param name="outStream">Stream to write to.</param>
            <param name="codec">Codec to use when writing.</param>
            <returns>A new file writer.</returns>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.OpenWriter(Avro.Generic.DatumWriter{`0},System.IO.Stream,Avro.File.Codec,System.Boolean)">
            <summary>
            Open a new writer instance to write
            to an output stream with a specified codec
            </summary>
            <param name="writer">Datum writer to use.</param>
            <param name="outStream">Stream to write to.</param>
            <param name="codec">Codec to use when writing.</param>
            <param name="leaveOpen">Leave the stream open after disposing the object</param>
            <returns>A new file writer.</returns>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.OpenAppendWriter(Avro.Generic.DatumWriter{`0},System.String)">
            <summary>
            Open a new writer instance to append to a file path.
            </summary>
            <param name="writer">Datum writer to use.</param>
            <param name="path">Path to the file.</param>
            <returns>A new file writer.</returns>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.OpenAppendWriter(Avro.Generic.DatumWriter{`0},System.IO.Stream,System.IO.Stream)">
            <summary>
            Open a new writer instance to append to an output stream.
            Both in and out streams must point to the same file.
            </summary>
            <param name="writer">Datum writer to use.</param>
            <param name="inStream">reading the existing file.</param>
            <param name="outStream">stream to write to, positioned at the end of the existing file.</param>
            <returns>A new file writer.</returns>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.IsReservedMeta(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.SetMeta(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.SetMeta(System.String,System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.SetMeta(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.SetSyncInterval(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.Append(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.Sync">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.Close">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.Dispose">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DataFileWriter`1.Dispose(System.Boolean)">
            <summary>
            Releases resources associated with this <see cref="T:Avro.File.DataFileWriter`1"/>.
            </summary>
            <param name="disposing">
            True if called from <see cref="M:Avro.File.DataFileWriter`1.Dispose"/>; false otherwise.
            </param>
        </member>
        <member name="T:Avro.File.DeflateCodec">
            <summary>
            Implements deflate compression and decompression.
            </summary>
            <seealso cref="T:System.IO.Compression.DeflateStream"/>
        </member>
        <member name="M:Avro.File.DeflateCodec.Compress(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DeflateCodec.Compress(System.IO.MemoryStream,System.IO.MemoryStream)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DeflateCodec.Decompress(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DeflateCodec.GetName">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DeflateCodec.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.DeflateCodec.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Avro.File.Header">
            <summary>
            Header on an Avro data file.
            </summary>
        </member>
        <member name="P:Avro.File.Header.MetaData">
            <summary>
            Metadata in this header.
            </summary>
        </member>
        <member name="P:Avro.File.Header.SyncData">
            <summary>
            Sync token.
            </summary>
        </member>
        <member name="P:Avro.File.Header.Schema">
            <summary>
            Avro schema.
            </summary>
        </member>
        <member name="M:Avro.File.Header.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.File.Header"/> class.
            </summary>
        </member>
        <member name="T:Avro.File.IFileReader`1">
            <summary>
            Defines the interface for an object that reads data from a file.
            </summary>
            <typeparam name="T">Type to serialize data to.</typeparam>
        </member>
        <member name="M:Avro.File.IFileReader`1.GetHeader">
            <summary>
            Return the header for the input file or stream.
            </summary>
            <returns>Parsed header from the file or stream.</returns>
        </member>
        <member name="M:Avro.File.IFileReader`1.GetSchema">
            <summary>
            Return the schema as read from the file or stream.
            </summary>
            <returns>Parse schema from the file or stream.</returns>
        </member>
        <member name="M:Avro.File.IFileReader`1.GetMetaKeys">
            <summary>
            Return the list of keys in the metadata.
            </summary>
            <returns>Metadata keys from the header of the data file.</returns>
        </member>
        <member name="P:Avro.File.IFileReader`1.NextEntries">
            <summary>
            Return an enumeration of the remaining entries in the file.
            </summary>
            <returns>An enumeration of the remaining entries in the file.</returns>
        </member>
        <member name="M:Avro.File.IFileReader`1.Next">
            <summary>
            Read the next datum from the file.
            </summary>
            <returns>Next deserialized data entry.</returns>
        </member>
        <member name="M:Avro.File.IFileReader`1.HasNext">
            <summary>
            Returns true if more entries remain in this file.
            </summary>
            <returns>True if more entries remain in this file, false otherwise.</returns>
        </member>
        <member name="M:Avro.File.IFileReader`1.GetMeta(System.String)">
            <summary>
            Return the byte value of a metadata property.
            </summary>
            <param name="key">Key for the metadata entry.</param>
            <returns>Raw bytes of the value of the metadata entry.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            There is no metadata entry with the specified <paramref name="key"/>.
            </exception>
        </member>
        <member name="M:Avro.File.IFileReader`1.GetMetaLong(System.String)">
            <summary>
            Return the long value of a metadata property.
            </summary>
            <param name="key">Key for the metadata entry.</param>
            <returns>Metadata value as a long.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            There is no metadata entry with the specified <paramref name="key"/>.
            </exception>
        </member>
        <member name="M:Avro.File.IFileReader`1.GetMetaString(System.String)">
            <summary>
            Return the string value of a metadata property. This method assumes that the string is a
            UTF-8 encoded in the header.
            </summary>
            <param name="key">Key for the metadata entry.</param>
            <returns>Metadata value as a string.</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            There is no metadata entry with the specified <paramref name="key"/>.
            </exception>
            <exception cref="T:Avro.AvroRuntimeException">
            Encountered an exception while decoding the value as a UTF-8 string.
            </exception>
        </member>
        <member name="M:Avro.File.IFileReader`1.PastSync(System.Int64)">
            <summary>
            Return true if past the next synchronization point after a position.
            </summary>
            <param name="position">Position to test.</param>
            <returns>
            True if pasth the next synchronization point after <paramref name="position"/>, false
            otherwise.
            </returns>
        </member>
        <member name="M:Avro.File.IFileReader`1.PreviousSync">
            <summary>
            Return the last synchronization point before our current position.
            </summary>
            <returns>
            Position of the last synchronization point before our current position.
            </returns>
        </member>
        <member name="M:Avro.File.IFileReader`1.Seek(System.Int64)">
            <summary>
            Move to a specific, known synchronization point,
            one returned from <see cref="M:Avro.File.IFileWriter`1.Sync"/> while writing.
            </summary>
            <param name="position">Position to jump to.</param>
        </member>
        <member name="M:Avro.File.IFileReader`1.Sync(System.Int64)">
            <summary>
            Move to the next synchronization point after a position.
            </summary>
            <param name="position">Position in the stream to start.</param>
        </member>
        <member name="M:Avro.File.IFileReader`1.Tell">
            <summary>
            Return the current position in the input.
            </summary>
            <returns>Current position in the input.</returns>
        </member>
        <member name="T:Avro.File.IFileWriter`1">
            <summary>
            Defines the interface for an object that stores in a file a sequence of data conforming to
            a schema.
            </summary>
            <typeparam name="T">Type that we will serialize to the file.</typeparam>
        </member>
        <member name="M:Avro.File.IFileWriter`1.Append(`0)">
            <summary>
            Append datum to a file or stream.
            </summary>
            <param name="datum">Datum to append.</param>
        </member>
        <member name="M:Avro.File.IFileWriter`1.Close">
            <summary>
            Closes the file or stream.
            </summary>
        </member>
        <member name="M:Avro.File.IFileWriter`1.Flush">
            <summary>
            Flush out any buffered data.
            </summary>
        </member>
        <member name="M:Avro.File.IFileWriter`1.IsReservedMeta(System.String)">
            <summary>
            Returns true if parameter is a reserved Avro metadata value.
            </summary>
            <param name="key">Metadata key.</param>
            <returns>
            True if parameter is a reserved Avro metadata value, false otherwise.
            </returns>
        </member>
        <member name="M:Avro.File.IFileWriter`1.SetMeta(System.String,System.Byte[])">
            <summary>
            Set metadata pair.
            </summary>
            <param name="key">Metadata key.</param>
            <param name="value">Metadata value.</param>
        </member>
        <member name="M:Avro.File.IFileWriter`1.SetMeta(System.String,System.Int64)">
            <summary>
            Set metadata pair (long value).
            </summary>
            <param name="key">Metadata key.</param>
            <param name="value">Metadata value.</param>
        </member>
        <member name="M:Avro.File.IFileWriter`1.SetMeta(System.String,System.String)">
            <summary>
            Set metadata pair (string value).
            </summary>
            <param name="key">Metadata key.</param>
            <param name="value">Metadata value.</param>
        </member>
        <member name="M:Avro.File.IFileWriter`1.SetSyncInterval(System.Int32)">
            <summary>
            Set the synchronization interval for this file or stream, in bytes. Valid values range
            from 32 to 2^30. Suggested values are between 2K and 2M.
            </summary>
            <param name="syncInterval">
            Approximate number of uncompressed bytes to write in each block.
            </param>
        </member>
        <member name="M:Avro.File.IFileWriter`1.Sync">
            <summary>
            Forces the end of the current block, emitting a synchronization marker.
            </summary>
            <returns>
            Current position as a value that may be passed to
            <see cref="M:Avro.File.IFileReader`1.Seek(System.Int64)"/>.
            </returns>
        </member>
        <member name="T:Avro.File.NullCodec">
            <summary>
            Implements a codec that does not perform any compression. This codec simply returns the
            bytes presented to it "as-is".
            </summary>
        </member>
        <member name="M:Avro.File.NullCodec.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.File.NullCodec"/> class.
            </summary>
        </member>
        <member name="M:Avro.File.NullCodec.Compress(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.NullCodec.Compress(System.IO.MemoryStream,System.IO.MemoryStream)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.NullCodec.Decompress(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.NullCodec.GetName">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.NullCodec.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.File.NullCodec.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Generic.DatumReader`1">
            <summary>
            Defines the interface for an object that reads data of a schema.
            </summary>
            <typeparam name="T">Type of the in-memory data representation.</typeparam>
        </member>
        <member name="P:Avro.Generic.DatumReader`1.ReaderSchema">
            <summary>
            Schema used to read the data.
            </summary>
        </member>
        <member name="P:Avro.Generic.DatumReader`1.WriterSchema">
            <summary>
            Schema that was used to write the data.
            </summary>
        </member>
        <member name="M:Avro.Generic.DatumReader`1.Read(`0,Avro.IO.Decoder)">
            <summary>
            Read a datum.  Traverse the schema, depth-first, reading all leaf values
            in the schema into a datum that is returned.  If the provided datum is
            non-null it may be reused and returned.
            </summary>
            <param name="reuse">Optional object to deserialize the datum into. May be null.</param>
            <param name="decoder">Decoder to read data from.</param>
            <returns>Deserialized datum.</returns>
        </member>
        <member name="T:Avro.Generic.DatumWriter`1">
            <summary>
            Defines the interface for an object that writes data of a schema.
            </summary>
            <typeparam name="T">Type of the in-memory data representation.</typeparam>
        </member>
        <member name="P:Avro.Generic.DatumWriter`1.Schema">
            <summary>
            Schema used to write the data.
            </summary>
        </member>
        <member name="M:Avro.Generic.DatumWriter`1.Write(`0,Avro.IO.Encoder)">
            <summary>
            Write a datum. Traverse the schema, depth first, writing each leaf value in the schema
            from the datum to the output.
            </summary>
            <param name="datum">Datum to write</param>
            <param name="encoder">Encoder to write to</param>
        </member>
        <member name="T:Avro.Generic.GenericDatumReader`1">
            <summary>
            <see cref="T:Avro.Generic.PreresolvingDatumReader`1"/> for reading data to <see cref="T:Avro.Generic.GenericRecord"/>
            classes or primitives.
            <see cref="T:Avro.Generic.PreresolvingDatumReader`1">For more information about performance considerations
            for choosing this implementation</see>.
            </summary>
            <typeparam name="T">Type to deserialize data into.</typeparam>
        </member>
        <member name="M:Avro.Generic.GenericDatumReader`1.#ctor(Avro.Schema,Avro.Schema)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Generic.GenericDatumReader`1"/> class.
            </summary>
            <param name="writerSchema">Schema that was used to write the data.</param>
            <param name="readerSchema">Schema to use to read the data.</param>
        </member>
        <member name="M:Avro.Generic.GenericDatumReader`1.IsReusable(Avro.Schema.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericDatumReader`1.GetArrayAccess(Avro.ArraySchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericDatumReader`1.GetEnumAccess(Avro.EnumSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericDatumReader`1.GetMapAccess(Avro.MapSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericDatumReader`1.GetRecordAccess(Avro.RecordSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericDatumReader`1.GetFixedAccess(Avro.FixedSchema)">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Generic.GenericDatumWriter`1">
            <summary>
            PreresolvingDatumWriter for writing data from GenericRecords or primitive types.
            <see cref="T:Avro.Generic.PreresolvingDatumWriter`1">For more information about performance considerations for choosing this implementation</see>
            </summary>
        </member>
        <member name="M:Avro.Generic.GenericDatumWriter`1.#ctor(Avro.Schema)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Generic.GenericDatumWriter`1"/> class.
            </summary>
            <param name="schema">Schema this writer will use.</param>
        </member>
        <member name="M:Avro.Generic.GenericDatumWriter`1.WriteRecordFields(System.Object,Avro.Generic.PreresolvingDatumWriter{`0}.RecordFieldWriter[],Avro.IO.Encoder)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericDatumWriter`1.EnsureRecordObject(Avro.RecordSchema,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericDatumWriter`1.WriteField(System.Object,System.String,System.Int32,Avro.Generic.PreresolvingDatumWriter{`0}.WriteItem,Avro.IO.Encoder)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericDatumWriter`1.ResolveEnum(Avro.EnumSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericDatumWriter`1.WriteFixed(Avro.FixedSchema,System.Object,Avro.IO.Encoder)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericDatumWriter`1.UnionBranchMatches(Avro.Schema,System.Object)">
            <summary>
            Tests whether the given schema an object are compatible.
            </summary>
            <remarks>
            FIXME: This method of determining the Union branch has problems. If the data is IDictionary&lt;string, object&gt;
            if there are two branches one with record schema and the other with map, it choose the first one. Similarly if
            the data is byte[] and there are fixed and bytes schemas as branches, it choose the first one that matches.
            Also it does not recognize the arrays of primitive types.
            </remarks>
            <param name="sc">Schema to compare</param>
            <param name="obj">Object to compare</param>
            <returns>True if the two parameters are compatible, false otherwise.</returns>
        </member>
        <member name="T:Avro.Generic.GenericEnum">
            <summary>
            The default class to hold values for enum schema in GenericReader and GenericWriter.
            </summary>
        </member>
        <member name="P:Avro.Generic.GenericEnum.Schema">
            <summary>
            Schema for this enum.
            </summary>
        </member>
        <member name="P:Avro.Generic.GenericEnum.Value">
            <summary>
            Value of the enum.
            </summary>
        </member>
        <member name="M:Avro.Generic.GenericEnum.#ctor(Avro.EnumSchema,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Generic.GenericEnum"/> class.
            </summary>
            <param name="schema">Schema for this enum.</param>
            <param name="value">Value of the enum.</param>
        </member>
        <member name="M:Avro.Generic.GenericEnum.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericEnum.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericEnum.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Generic.GenericFixed">
            <summary>
            The default type used by GenericReader and GenericWriter for objects for FixedSchema
            </summary>
        </member>
        <member name="F:Avro.Generic.GenericFixed.value">
            <summary>
            Value of this fixed.
            </summary>
        </member>
        <member name="P:Avro.Generic.GenericFixed.Schema">
            <summary>
            Schema for this fixed.
            </summary>
        </member>
        <member name="M:Avro.Generic.GenericFixed.#ctor(Avro.FixedSchema)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Generic.GenericFixed"/> class.
            </summary>
            <param name="schema">Schema for this fixed.</param>
        </member>
        <member name="M:Avro.Generic.GenericFixed.#ctor(Avro.FixedSchema,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Generic.GenericFixed"/> class with a value.
            </summary>
            <param name="schema">Schema for this fixed.</param>
            <param name="value">Value of the fixed.</param>
        </member>
        <member name="M:Avro.Generic.GenericFixed.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Generic.GenericFixed"/> class with a size.
            </summary>
            <param name="size">Size of the fixed in bytes.</param>
        </member>
        <member name="P:Avro.Generic.GenericFixed.Value">
            <summary>
            Value of this fixed.
            </summary>
        </member>
        <member name="M:Avro.Generic.GenericFixed.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericFixed.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Generic.Reader`1">
            <summary>
            A function that can read the Avro type from the stream.
            </summary>
            <typeparam name="T">Type to read.</typeparam>
            <returns>The read object.</returns>
        </member>
        <member name="T:Avro.Generic.GenericReader`1">
            <summary>
            A general purpose reader of data from avro streams. This can optionally resolve if the reader's and writer's
            schemas are different. This class is a wrapper around DefaultReader and offers a little more type safety. The default reader
            has the flexibility to return any type of object for each read call because the Read() method is generic. This
            class on the other hand can only return a single type because the type is a parameter to the class. Any
            user defined extension should, however, be done to DefaultReader. This class is sealed.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Avro.Generic.GenericReader`1.#ctor(Avro.Schema,Avro.Schema)">
            <summary>
            Constructs a generic reader for the given schemas using the DefaultReader. If the
            reader's and writer's schemas are different this class performs the resolution.
            </summary>
            <param name="writerSchema">The schema used while generating the data</param>
            <param name="readerSchema">The schema desired by the reader</param>
        </member>
        <member name="M:Avro.Generic.GenericReader`1.#ctor(Avro.Generic.DefaultReader)">
            <summary>
            Constructs a generic reader by directly using the given DefaultReader
            </summary>
            <param name="reader">The actual reader to use</param>
        </member>
        <member name="P:Avro.Generic.GenericReader`1.WriterSchema">
            <summary>
            Schema used to write the data.
            </summary>
        </member>
        <member name="P:Avro.Generic.GenericReader`1.ReaderSchema">
            <summary>
            Schema used to read the data.
            </summary>
        </member>
        <member name="M:Avro.Generic.GenericReader`1.Read(`0,Avro.IO.Decoder)">
            <summary>
            Reads an object off the stream.
            </summary>
            <param name="reuse">
            If not null, the implemenation will try to use to return the object
            </param>
            <param name="d">Decoder to read from.</param>
            <returns>Object we read from the decoder.</returns>
        </member>
        <member name="T:Avro.Generic.DefaultReader">
            <summary>
            The default implementation for the generic reader. It constructs new .NET objects for avro objects on the
            stream and returns the .NET object. Users can directly use this class or, if they want to customize the
            object types for differnt Avro schema types, can derive from this class. There are enough hooks in this
            class to allow customization.
            </summary>
            <remarks>
            <list type="table">
            <listheader><term>Avro Type</term><description>.NET Type</description></listheader>
            <item><term>null</term><description>null reference</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Avro.Generic.DefaultReader.ReaderSchema">
            <summary>
            Schema to use when reading data with this reader.
            </summary>
        </member>
        <member name="P:Avro.Generic.DefaultReader.WriterSchema">
            <summary>
            Schema used to write data that we are reading with this reader.
            </summary>
        </member>
        <member name="M:Avro.Generic.DefaultReader.#ctor(Avro.Schema,Avro.Schema)">
            <summary>
            Constructs the default reader for the given schemas using the DefaultReader. If the
            reader's and writer's schemas are different this class performs the resolution.
            This default implemenation maps Avro types to .NET types as follows:
            </summary>
            <param name="writerSchema">The schema used while generating the data</param>
            <param name="readerSchema">The schema desired by the reader</param>
        </member>
        <member name="M:Avro.Generic.DefaultReader.Read``1(``0,Avro.IO.Decoder)">
            <summary>
            Reads an object off the stream.
            </summary>
            <typeparam name="T">The type of object to read. A single schema typically returns an object of a single .NET class.
            The only exception is UnionSchema, which can return a object of different types based on the branch selected.
            </typeparam>
            <param name="reuse">If not null, the implemenation will try to use to return the object</param>
            <param name="decoder">The decoder for deserialization</param>
            <returns>Object read from the decoder.</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.Read(System.Object,Avro.Schema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Reads an object off the stream.
            </summary>
            <param name="reuse">
            If not null, the implemenation will try to use to return the object.
            </param>
            <param name="writerSchema">Schema used to write the data.</param>
            <param name="readerSchema">Schema to use when reading the data.</param>
            <param name="d">Decoder to read from.</param>
            <returns>Object read from the decoder.</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.ReadNull(Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Deserializes a null from the stream.
            </summary>
            <param name="readerSchema">Reader's schema, which should be a NullSchema</param>
            <param name="d">The decoder for deserialization</param>
            <returns></returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.Read``1(Avro.Schema.Type,Avro.Schema,Avro.Generic.Reader{``0})">
            <summary>
            A generic function to read primitive types
            </summary>
            <typeparam name="T">The .NET type to read</typeparam>
            <param name="tag">The Avro type tag for the object on the stream</param>
            <param name="readerSchema">A schema compatible to the Avro type</param>
            <param name="reader">A function that can read the avro type from the stream</param>
            <returns>The primitive type just read</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.ReadRecord(System.Object,Avro.RecordSchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Deserializes a record from the stream.
            </summary>
            <param name="reuse">If not null, a record object that could be reused for returning the result</param>
            <param name="writerSchema">The writer's RecordSchema</param>
            <param name="readerSchema">The reader's schema, must be RecordSchema too.</param>
            <param name="dec">The decoder for deserialization</param>
            <returns>The record object just read</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.CreateRecord(System.Object,Avro.RecordSchema)">
            <summary>
            Creates a new record object. Derived classes can override this to return an object of their choice.
            </summary>
            <param name="reuse">If appropriate, will reuse this object instead of constructing a new one</param>
            <param name="readerSchema">The schema the reader is using</param>
            <returns></returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.TryGetField(System.Object,System.String,System.Int32,System.Object@)">
            <summary>
            Used by the default implementation of ReadRecord() to get the existing field of a record object. The derived
            classes can override this to make their own interpretation of the record object.
            </summary>
            <param name="record">The record object to be probed into. This is guaranteed to be one that was returned
            by a previous call to CreateRecord.</param>
            <param name="fieldName">The name of the field to probe.</param>
            <param name="fieldPos">Position of the field in the schema - not used in the base implementation.</param>
            <param name="value">The value of the field, if found. Null otherwise.</param>
            <returns>True if and only if a field with the given name is found.</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.AddField(System.Object,System.String,System.Int32,System.Object)">
            <summary>
            Used by the default implementation of ReadRecord() to add a field to a record object. The derived
            classes can override this to suit their own implementation of the record object.
            </summary>
            <param name="record">The record object to be probed into. This is guaranteed to be one that was returned
            by a previous call to CreateRecord.</param>
            <param name="fieldName">The name of the field to probe.</param>
            <param name="fieldPos">Position of the field in the schema - not used in the base implementation.</param>
            <param name="fieldValue">The value to be added for the field</param>
        </member>
        <member name="M:Avro.Generic.DefaultReader.ReadEnum(System.Object,Avro.EnumSchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Deserializes a enum. Uses CreateEnum to construct the new enum object.
            </summary>
            <param name="reuse">If appropirate, uses this instead of creating a new enum object.</param>
            <param name="writerSchema">The schema the writer used while writing the enum</param>
            <param name="readerSchema">The schema the reader is using</param>
            <param name="d">The decoder for deserialization.</param>
            <returns>An enum object.</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.CreateEnum(System.Object,Avro.EnumSchema,System.String)">
            <summary>
            Used by the default implementation of ReadEnum to construct a new enum object.
            </summary>
            <param name="reuse">If appropriate, use this enum object instead of a new one.</param>
            <param name="es">The enum schema used by the reader.</param>
            <param name="symbol">The symbol that needs to be used.</param>
            <returns>The default implemenation returns a GenericEnum.</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.ReadArray(System.Object,Avro.ArraySchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Deserializes an array and returns an array object. It uses CreateArray() and works on it before returning it.
            It also uses GetArraySize(), ResizeArray(), SetArrayElement() and GetArrayElement() methods. Derived classes can
            override these methods to customize their behavior.
            </summary>
            <param name="reuse">If appropriate, uses this instead of creating a new array object.</param>
            <param name="writerSchema">The schema used by the writer.</param>
            <param name="readerSchema">The schema that the reader uses.</param>
            <param name="d">The decoder for deserialization.</param>
            <returns>The deserialized array object.</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.CreateArray(System.Object,Avro.ArraySchema)">
            <summary>
            Creates a new array object. The initial size of the object could be anything. The users
            should use GetArraySize() to determine the size. The default implementation creates an <c>object[]</c>.
            </summary>
            <param name="reuse">If appropriate use this instead of creating a new one.</param>
            <param name="rs">Array schema, not used in base implementation</param>
            <returns>An object suitable to deserialize an avro array</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.GetArraySize(System.Object)">
            <summary>
            Returns the size of the given array object.
            </summary>
            <param name="array">Array object whose size is required. This is guaranteed to be somthing returned by
            a previous call to CreateArray().</param>
            <returns>The size of the array</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.ResizeArray(System.Object@,System.Int32)">
            <summary>
            Resizes the array to the new value.
            </summary>
            <param name="array">Array object whose size is required. This is guaranteed to be somthing returned by
            a previous call to CreateArray().</param>
            <param name="n">The new size.</param>
        </member>
        <member name="M:Avro.Generic.DefaultReader.SetArrayElement(System.Object,System.Int32,System.Object)">
            <summary>
            Assigns a new value to the object at the given index
            </summary>
            <param name="array">Array object whose size is required. This is guaranteed to be somthing returned by
            a previous call to CreateArray().</param>
            <param name="index">The index to reassign to.</param>
            <param name="value">The value to assign.</param>
        </member>
        <member name="M:Avro.Generic.DefaultReader.GetArrayElement(System.Object,System.Int32)">
            <summary>
            Returns the element at the given index.
            </summary>
            <param name="array">Array object whose size is required. This is guaranteed to be somthing returned by
            a previous call to CreateArray().</param>
            <param name="index">The index to look into.</param>
            <returns>The object the given index. Null if no object has been assigned to that index.</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.ReadMap(System.Object,Avro.MapSchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Deserialized an avro map. The default implemenation creats a new map using CreateMap() and then
            adds elements to the map using AddMapEntry().
            </summary>
            <param name="reuse">If appropriate, use this instead of creating a new map object.</param>
            <param name="writerSchema">The schema the writer used to write the map.</param>
            <param name="readerSchema">The schema the reader is using.</param>
            <param name="d">The decoder for serialization.</param>
            <returns>The deserialized map object.</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.CreateMap(System.Object,Avro.MapSchema)">
            <summary>
            Used by the default implementation of ReadMap() to create a fresh map object. The default
            implementaion of this method returns a IDictionary&lt;string, map&gt;.
            </summary>
            <param name="reuse">If appropriate, use this map object instead of creating a new one.</param>
            <param name="ms">Map schema to use when creating the object.</param>
            <returns>An empty map object.</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.AddMapEntry(System.Object,System.String,System.Object)">
            <summary>
            Adds an entry to the map.
            </summary>
            <param name="map">A map object, which is guaranteed to be one returned by a previous call to CreateMap().</param>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
        </member>
        <member name="M:Avro.Generic.DefaultReader.ReadUnion(System.Object,Avro.UnionSchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Deserialized an object based on the writer's uninon schema.
            </summary>
            <param name="reuse">If appropriate, uses this object instead of creating a new one.</param>
            <param name="writerSchema">The UnionSchema that the writer used.</param>
            <param name="readerSchema">The schema the reader uses.</param>
            <param name="d">The decoder for serialization.</param>
            <returns>The deserialized object.</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.ReadLogical(System.Object,Avro.LogicalSchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Deserializes an object based on the writer's logical schema. Uses the underlying logical type to convert
            the value to the logical type.
            </summary>
            <param name="reuse">If appropriate, uses this object instead of creating a new one.</param>
            <param name="writerSchema">The UnionSchema that the writer used.</param>
            <param name="readerSchema">The schema the reader uses.</param>
            <param name="d">The decoder for serialization.</param>
            <returns>The deserialized object.</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.ReadFixed(System.Object,Avro.FixedSchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Deserializes a fixed object and returns the object. The default implementation uses CreateFixed()
            and GetFixedBuffer() and returns what CreateFixed() returned.
            </summary>
            <param name="reuse">If appropriate, uses this object instead of creating a new one.</param>
            <param name="writerSchema">The FixedSchema the writer used during serialization.</param>
            <param name="readerSchema">The schema that the readr uses. Must be a FixedSchema with the same
            size as the writerSchema.</param>
            <param name="d">The decoder for deserialization.</param>
            <returns>The deserilized object.</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.CreateFixed(System.Object,Avro.FixedSchema)">
            <summary>
            Returns a fixed object.
            </summary>
            <param name="reuse">If appropriate, uses this object instead of creating a new one.</param>
            <param name="rs">The reader's FixedSchema.</param>
            <returns>A fixed object with an appropriate buffer.</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.GetFixedBuffer(System.Object)">
            <summary>
            Returns a buffer of appropriate size to read data into.
            </summary>
            <param name="f">The fixed object. It is guaranteed that this is something that has been previously
            returned by CreateFixed</param>
            <returns>A byte buffer of fixed's size.</returns>
        </member>
        <member name="M:Avro.Generic.DefaultReader.Skip(Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Skip an instance of a schema.
            </summary>
            <param name="writerSchema">Schema to skip.</param>
            <param name="d">Decoder we're reading from.</param>
        </member>
        <member name="M:Avro.Generic.DefaultReader.findBranch(Avro.UnionSchema,Avro.Schema)">
            <summary>
            Finds the branch of the union schema associated with the given schema.
            </summary>
            <param name="us">Union schema.</param>
            <param name="s">Schema to find in the union schema.</param>
            <returns>Schema branch in the union schema.</returns>
        </member>
        <member name="T:Avro.Generic.GenericRecord">
            <summary>
            The default type used by GenericReader and GenericWriter for RecordSchema.
            </summary>
        </member>
        <member name="P:Avro.Generic.GenericRecord.Schema">
            <summary>
            Schema for this record.
            </summary>
        </member>
        <member name="M:Avro.Generic.GenericRecord.#ctor(Avro.RecordSchema)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Generic.GenericRecord"/> class.
            </summary>
            <param name="schema">Schema for this record.</param>
        </member>
        <member name="P:Avro.Generic.GenericRecord.Item(System.String)">
            <summary>
            Returns the value of the field with the given name.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <returns>Value of the field with the given name.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="fieldName"/> is null.
            </exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            <paramref name="fieldName"/> does not exist in this record.
            </exception>
        </member>
        <member name="M:Avro.Generic.GenericRecord.Add(System.String,System.Object)">
            <summary>
            Sets the value for a field. You may call this method multiple times with the same
            field name to change its value. The given field name must exist in the schema.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <param name="fieldValue">Value of the field.</param>
            <exception cref="T:Avro.AvroException">
            <paramref name="fieldName"/> does not exist in this record.
            </exception>
        </member>
        <member name="M:Avro.Generic.GenericRecord.TryGetValue(System.String,System.Object@)">
            <summary>
            Gets the value the specified field name.
            </summary>
            <param name="fieldName">Name of the field.</param>
            <param name="result">
            When this method returns true, contains the value of the specified field;
            otherwise, null.
            </param>
            <returns>
            True if the field was found in the record. This method will only return true if
            <see cref="M:Avro.Generic.GenericRecord.Add(System.String,System.Object)"/> has been called for the given field name.
            </returns>
        </member>
        <member name="M:Avro.Generic.GenericRecord.GetValue(System.Int32)">
            <summary>
            Returns the value of the field with the given position.
            </summary>
            <param name="fieldPos">The position of the field.</param>
            <returns>Value of the field with the given position.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            <paramref name="fieldPos"/>
            </exception>
        </member>
        <member name="M:Avro.Generic.GenericRecord.Add(System.Int32,System.Object)">
            <summary>
            Adds the value in the specified field position.
            </summary>
            <param name="fieldPos">Position of the field.</param>
            <param name="fieldValue">The value to add.</param>
            <exception cref="T:System.IndexOutOfRangeException">
            <paramref name="fieldPos"/>.
            </exception>
        </member>
        <member name="M:Avro.Generic.GenericRecord.TryGetValue(System.Int32,System.Object@)">
            <summary>
            Gets the value in the specified field position.
            </summary>
            <param name="fieldPos">Position of the field.</param>
            <param name="result">
            When this method returns true, contains the value of the specified field;
            otherwise, null.
            </param>
            <returns>
            True if the field position is valid.
            </returns>
        </member>
        <member name="M:Avro.Generic.GenericRecord.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericRecord.Equals(Avro.Generic.GenericRecord)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericRecord.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericRecord.ToString">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Generic.Writer`1">
            <summary>
            Defines the signature for a function that writes an object.
            </summary>
            <typeparam name="T">Type of object to write.</typeparam>
            <param name="t">Object to write.</param>
        </member>
        <member name="T:Avro.Generic.GenericWriter`1">
            <summary>
            A typesafe wrapper around DefaultWriter. While a specific object of DefaultWriter
            allows the client to serialize a generic type, an object of this class allows
            only a single type of object to be serialized through it.
            </summary>
            <typeparam name="T">The type of object to be serialized.</typeparam>
        </member>
        <member name="M:Avro.Generic.GenericWriter`1.#ctor(Avro.Schema)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Generic.GenericWriter`1"/> class.
            </summary>
            <param name="schema">Schema to use when writing.</param>
        </member>
        <member name="P:Avro.Generic.GenericWriter`1.Schema">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.GenericWriter`1.#ctor(Avro.Generic.DefaultWriter)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Generic.GenericWriter`1"/> class from a
            <see cref="T:Avro.Generic.DefaultWriter"/>.
            </summary>
            <param name="writer">Write to initialize this new writer from.</param>
        </member>
        <member name="M:Avro.Generic.GenericWriter`1.Write(`0,Avro.IO.Encoder)">
            <summary>
            Serializes the given object using this writer's schema.
            </summary>
            <param name="value">The value to be serialized</param>
            <param name="encoder">The encoder to use for serializing</param>
        </member>
        <member name="T:Avro.Generic.DefaultWriter">
            <summary>
            A General purpose writer for serializing objects into a Stream using
            Avro. This class implements a default way of serializing objects. But
            one can derive a class from this and override different methods to
            acheive results that are different from the default implementation.
            </summary>
        </member>
        <member name="P:Avro.Generic.DefaultWriter.Schema">
            <summary>
            Schema that this object uses to write datum.
            </summary>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.#ctor(Avro.Schema)">
            <summary>
            Constructs a generic writer for the given schema.
            </summary>
            <param name="schema">The schema for the object to be serialized</param>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.Write``1(``0,Avro.IO.Encoder)">
            <summary>
            Examines the <see cref="P:Avro.Generic.DefaultWriter.Schema"/> and dispatches the actual work to one
            of the other methods of this class. This allows the derived
            classes to override specific methods and get custom results.
            </summary>
            <param name="value">The value to be serialized</param>
            <param name="encoder">The encoder to use during serialization</param>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.Write(Avro.Schema,System.Object,Avro.IO.Encoder)">
            <summary>
            Examines the schema and dispatches the actual work to one
            of the other methods of this class. This allows the derived
            classes to override specific methods and get custom results.
            </summary>
            <param name="schema">The schema to use for serializing</param>
            <param name="value">The value to be serialized</param>
            <param name="encoder">The encoder to use during serialization</param>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.WriteNull(System.Object,Avro.IO.Encoder)">
            <summary>
            Serializes a "null"
            </summary>
            <param name="value">The object to be serialized using null schema</param>
            <param name="encoder">The encoder to use while serialization</param>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.Write``1(System.Object,Avro.Schema.Type,Avro.Generic.Writer{``0})">
            <summary>
            A generic method to serialize primitive Avro types.
            </summary>
            <typeparam name="T">Type of the C# type to be serialized</typeparam>
            <param name="value">The value to be serialized</param>
            <param name="tag">The schema type tag</param>
            <param name="writer">The writer which should be used to write the given type.</param>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.WriteRecord(Avro.RecordSchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Serialized a record using the given RecordSchema. It uses GetField method
            to extract the field value from the given object.
            </summary>
            <param name="schema">The RecordSchema to use for serialization</param>
            <param name="value">The value to be serialized</param>
            <param name="encoder">The Encoder for serialization</param>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.EnsureRecordObject(Avro.RecordSchema,System.Object)">
            <summary>
            Ensures that the given value is a record and that it corresponds to the given schema.
            Throws an exception if either of those assertions are false.
            </summary>
            <param name="s">Schema associated with the record</param>
            <param name="value">Ensure this object is a record</param>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.GetField(System.Object,System.String,System.Int32)">
            <summary>
            Extracts the field value from the given object. In this default implementation,
            value should be of type GenericRecord.
            </summary>
            <param name="value">The record value from which the field needs to be extracted</param>
            <param name="fieldName">The name of the field in the record</param>
            <param name="fieldPos">The position of field in the record</param>
            <returns></returns>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.WriteEnum(Avro.EnumSchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Serializes an enumeration. The default implementation expectes the value to be string whose
            value is the name of the enumeration.
            </summary>
            <param name="es">The EnumSchema for serialization</param>
            <param name="value">Value to be written</param>
            <param name="encoder">Encoder for serialization</param>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.WriteArray(Avro.ArraySchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Serialized an array. The default implementation calls EnsureArrayObject() to ascertain that the
            given value is an array. It then calls GetArrayLength() and GetArrayElement()
            to access the members of the array and then serialize them.
            </summary>
            <param name="schema">The ArraySchema for serialization</param>
            <param name="value">The value being serialized</param>
            <param name="encoder">The encoder for serialization</param>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.EnsureArrayObject(System.Object)">
            <summary>
            Checks if the given object is an array. If it is a valid array, this function returns normally. Otherwise,
            it throws an exception. The default implementation checks if the value is an array.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.GetArrayLength(System.Object)">
            <summary>
            Returns the length of an array. The default implementation requires the object
            to be an array of objects and returns its length. The defaul implementation
            gurantees that EnsureArrayObject() has been called on the value before this
            function is called.
            </summary>
            <param name="value">The object whose array length is required</param>
            <returns>The array length of the given object</returns>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.GetArrayElement(System.Object,System.Int64)">
            <summary>
            Returns the element at the given index from the given array object. The default implementation
            requires that the value is an object array and returns the element in that array. The defaul implementation
            gurantees that EnsureArrayObject() has been called on the value before this
            function is called.
            </summary>
            <param name="value">The array object</param>
            <param name="index">The index to look for</param>
            <returns>The array element at the index</returns>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.WriteMap(Avro.MapSchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Serialized a map. The default implementation first ensure that the value is indeed a map and then uses
            GetMapSize() and GetMapElements() to access the contents of the map.
            </summary>
            <param name="schema">The MapSchema for serialization</param>
            <param name="value">The value to be serialized</param>
            <param name="encoder">The encoder for serialization</param>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.EnsureMapObject(System.Object)">
            <summary>
            Checks if the given object is a map. If it is a valid map, this function returns normally. Otherwise,
            it throws an exception. The default implementation checks if the value is an IDictionary&lt;string, object&gt;.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.GetMapSize(System.Object)">
            <summary>
            Returns the size of the map object. The default implementation gurantees that EnsureMapObject has been
            successfully called with the given value. The default implementation requires the value
            to be an IDictionary&lt;string, object&gt; and returns the number of elements in it.
            </summary>
            <param name="value">The map object whose size is desired</param>
            <returns>The size of the given map object</returns>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.GetMapValues(System.Object)">
            <summary>
            Returns the contents of the given map object. The default implementation guarantees that EnsureMapObject
            has been called with the given value. The defualt implementation of this method requires that
            the value is an IDictionary&lt;string, object&gt; and returns its contents.
            </summary>
            <param name="value">The map object whose size is desired</param>
            <returns>The contents of the given map object</returns>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.WriteUnion(Avro.UnionSchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Resolves the given value against the given UnionSchema and serializes the object against
            the resolved schema member. The default implementation of this method uses
            ResolveUnion to find the member schema within the UnionSchema.
            </summary>
            <param name="us">The UnionSchema to resolve against</param>
            <param name="value">The value to be serialized</param>
            <param name="encoder">The encoder for serialization</param>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.ResolveUnion(Avro.UnionSchema,System.Object)">
            <summary>
            Finds the branch within the given UnionSchema that matches the given object. The default implementation
            calls Matches() method in the order of branches within the UnionSchema. If nothing matches, throws
            an exception.
            </summary>
            <param name="us">The UnionSchema to resolve against</param>
            <param name="obj">The object that should be used in matching</param>
            <returns></returns>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.WriteLogical(Avro.LogicalSchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Serializes a logical value object by using the underlying logical type to convert the value
            to its base value.
            </summary>
            <param name="ls">The schema for serialization</param>
            <param name="value">The value to be serialized</param>
            <param name="encoder">The encoder for serialization</param>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.WriteFixed(Avro.FixedSchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Serialized a fixed object. The default implementation requires that the value is
            a GenericFixed object with an identical schema as es.
            </summary>
            <param name="es">The schema for serialization</param>
            <param name="value">The value to be serialized</param>
            <param name="encoder">The encoder for serialization</param>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.TypeMismatch(System.Object,System.String,System.String)">
            <summary>
            Creates a new <see cref="T:Avro.AvroException"/> and uses the provided parameters to build an
            exception message indicathing there was a type mismatch.
            </summary>
            <param name="obj">Object whose type does not the expected type</param>
            <param name="schemaType">Schema that we tried to write against</param>
            <param name="type">Type that we expected</param>
            <returns>A new <see cref="T:Avro.AvroException"/> indicating a type mismatch.</returns>
        </member>
        <member name="M:Avro.Generic.DefaultWriter.Matches(Avro.Schema,System.Object)">
            <summary>
            Tests whether the given schema an object are compatible.
            </summary>
            <remarks>
            FIXME: This method of determining the Union branch has problems. If the data is IDictionary&lt;string, object&gt;
            if there are two branches one with record schema and the other with map, it choose the first one. Similarly if
            the data is byte[] and there are fixed and bytes schemas as branches, it choose the first one that matches.
            Also it does not recognize the arrays of primitive types.
            </remarks>
            <param name="sc">Schema to compare</param>
            <param name="obj">Object to compare</param>
            <returns>True if the two parameters are compatible, false otherwise.</returns>
        </member>
        <member name="T:Avro.Generic.PreresolvingDatumReader`1">
            <summary>
            A general purpose reader of data from avro streams. This reader analyzes and resolves the reader and writer schemas
            when constructed so that reads can be more efficient. Once constructed, a reader can be reused or shared among threads
            to avoid incurring more resolution costs.
            </summary>
        </member>
        <member name="P:Avro.Generic.PreresolvingDatumReader`1.ReaderSchema">
            <inheritdoc/>
        </member>
        <member name="P:Avro.Generic.PreresolvingDatumReader`1.WriterSchema">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Generic.PreresolvingDatumReader`1.ReadItem">
            <summary>
            Defines the signature for a function that reads an item from a decoder.
            </summary>
            <param name="reuse">Optional object to deserialize the datum into. May be null.</param>
            <param name="dec">Decoder to read data from.</param>
            <returns>Deserialized datum.</returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.#ctor(Avro.Schema,Avro.Schema)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Generic.PreresolvingDatumReader`1"/> class.
            </summary>
            <param name="writerSchema">Schema that was used to write the data.</param>
            <param name="readerSchema">Schema to use to read the data.</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.Read(`0,Avro.IO.Decoder)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.GetArrayAccess(Avro.ArraySchema)">
            <summary>
            Returns an <see cref="T:Avro.Generic.PreresolvingDatumReader`1.ArrayAccess"/> implementation for the given schema.
            </summary>
            <param name="readerSchema">Schema for the array.</param>
            <returns>An <see cref="T:Avro.Generic.PreresolvingDatumReader`1.ArrayAccess"/> implementation.</returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.GetEnumAccess(Avro.EnumSchema)">
            <summary>
            Returns an <see cref="T:Avro.Generic.PreresolvingDatumReader`1.EnumAccess"/> implementation for the given schema.
            </summary>
            <param name="readerSchema">Schema for the enum.</param>
            <returns>An <see cref="T:Avro.Generic.PreresolvingDatumReader`1.EnumAccess"/> implementation.</returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.GetMapAccess(Avro.MapSchema)">
            <summary>
            Returns a <see cref="T:Avro.Generic.PreresolvingDatumReader`1.MapAccess"/> implementation for the given schema.
            </summary>
            <param name="readerSchema">Schema for the map.</param>
            <returns>A <see cref="T:Avro.Generic.PreresolvingDatumReader`1.MapAccess"/> implementation.</returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.GetRecordAccess(Avro.RecordSchema)">
            <summary>
            Returns a <see cref="T:Avro.Generic.PreresolvingDatumReader`1.RecordAccess"/> implementation for the given schema.
            </summary>
            <param name="readerSchema">Schema for the record.</param>
            <returns>A <see cref="T:Avro.Generic.PreresolvingDatumReader`1.RecordAccess"/> implementation.</returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.GetFixedAccess(Avro.FixedSchema)">
            <summary>
            Returns a <see cref="T:Avro.Generic.PreresolvingDatumReader`1.FixedAccess"/> implementation for the given schema.
            </summary>
            <param name="readerSchema">Schema for the fixed.</param>
            <returns>A <see cref="T:Avro.Generic.PreresolvingDatumReader`1.FixedAccess"/> implementation.</returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.ResolveReader(Avro.Schema,Avro.Schema)">
            <summary>
            Build a reader that accounts for schema differences between the reader and writer schemas.
            </summary>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.FindBranch(Avro.UnionSchema,Avro.Schema)">
            <summary>
            Finds the branch of the union schema associated with the given schema.
            </summary>
            <param name="us">Union schema.</param>
            <param name="s">Schema to find in the union schema.</param>
            <returns>Schema branch in the union schema.</returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.IsReusable(Avro.Schema.Type)">
            <summary>
            Indicates if it's possible to reuse an object of the specified type. Generally
            false for immutable objects like int, long, string, etc but may differ between
            the Specific and Generic implementations. Used to avoid retrieving the existing
            value if it's not reusable.
            </summary>
            <param name="tag">Schema type to test for reusability.</param>
        </member>
        <member name="T:Avro.Generic.PreresolvingDatumReader`1.RecordAccess">
            <summary>
            Defines the interface for a class that provides access to a record implementation.
            </summary>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.RecordAccess.CreateRecord(System.Object)">
            <summary>
            Creates a new record object. Derived classes can override this to return an object of their choice.
            </summary>
            <param name="reuse">If appropriate, will reuse this object instead of constructing a new one</param>
            <returns></returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.RecordAccess.GetField(System.Object,System.String,System.Int32)">
            <summary>
            Used by the default implementation of ReadRecord() to get the existing field of a record object. The derived
            classes can override this to make their own interpretation of the record object.
            </summary>
            <param name="record">The record object to be probed into. This is guaranteed to be one that was returned
            by a previous call to CreateRecord.</param>
            <param name="fieldName">The name of the field to probe.</param>
            <param name="fieldPos">field number</param>
            <returns>The value of the field, if found. Null otherwise.</returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.RecordAccess.AddField(System.Object,System.String,System.Int32,System.Object)">
            <summary>
            Used by the default implementation of ReadRecord() to add a field to a record object. The derived
            classes can override this to suit their own implementation of the record object.
            </summary>
            <param name="record">The record object to be probed into. This is guaranteed to be one that was returned
            by a previous call to CreateRecord.</param>
            <param name="fieldName">The name of the field to probe.</param>
            <param name="fieldPos">field number</param>
            <param name="fieldValue">The value to be added for the field</param>
        </member>
        <member name="T:Avro.Generic.PreresolvingDatumReader`1.EnumAccess">
            <summary>
            Defines the interface for a class that provides access to an enum implementation.
            </summary>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.EnumAccess.CreateEnum(System.Object,System.Int32)">
            <summary>
            Creates an enum value.
            </summary>
            <param name="reuse">Optional object to reuse as the enum value. May be null.</param>
            <param name="ordinal">Ordinal value of the enum entry.</param>
            <returns>An object representing the enum value.</returns>
        </member>
        <member name="T:Avro.Generic.PreresolvingDatumReader`1.FixedAccess">
            <summary>
            Defines the interface for a class that provides access to a fixed implementation.
            </summary>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.FixedAccess.CreateFixed(System.Object)">
            <summary>
            Returns a fixed object.
            </summary>
            <param name="reuse">If appropriate, uses this object instead of creating a new one.</param>
            <returns>A fixed object with an appropriate buffer.</returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.FixedAccess.GetFixedBuffer(System.Object)">
            <summary>
            Returns a buffer of appropriate size to read data into.
            </summary>
            <param name="f">The fixed object. It is guaranteed that this is something that has been previously
            returned by CreateFixed</param>
            <returns>A byte buffer of fixed's size.</returns>
        </member>
        <member name="T:Avro.Generic.PreresolvingDatumReader`1.ArrayAccess">
            <summary>
            Defines the interface for a class that provides access to an array implementation.
            </summary>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.ArrayAccess.Create(System.Object)">
            <summary>
            Creates a new array object. The initial size of the object could be anything.
            </summary>
            <param name="reuse">If appropriate use this instead of creating a new one.</param>
            <returns>An object suitable to deserialize an avro array</returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.ArrayAccess.EnsureSize(System.Object@,System.Int32)">
            <summary>
            Hint that the array should be able to handle at least targetSize elements. The array
            is not required to be resized
            </summary>
            <param name="array">Array object who needs to support targetSize elements. This is guaranteed to be somthing returned by
            a previous call to CreateArray().</param>
            <param name="targetSize">The new size.</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.ArrayAccess.Resize(System.Object@,System.Int32)">
            <summary>
            Resizes the array to the new value.
            </summary>
            <param name="array">Array object whose size is required. This is guaranteed to be somthing returned by
            a previous call to CreateArray().</param>
            <param name="targetSize">The new size.</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.ArrayAccess.AddElements(System.Object,System.Int32,System.Int32,Avro.Generic.PreresolvingDatumReader{`0}.ReadItem,Avro.IO.Decoder,System.Boolean)">
            <summary>
            Adds elements to the given array by reading values from the decoder.
            </summary>
            <param name="array">Array to add elements to.</param>
            <param name="elements">Number of elements to add.</param>
            <param name="index">Start adding elements to the array at this index.</param>
            <param name="itemReader">Delegate to read an item from the decoder.</param>
            <param name="decoder">Decoder to read from.</param>
            <param name="reuse">
            True to reuse each element in the array when deserializing. False to create a new
            object for each element.
            </param>
        </member>
        <member name="T:Avro.Generic.PreresolvingDatumReader`1.MapAccess">
            <summary>
            Defines the interface for a class that provides access to a map implementation.
            </summary>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.MapAccess.Create(System.Object)">
            <summary>
            Creates a new map object.
            </summary>
            <param name="reuse">If appropriate, use this map object instead of creating a new one.</param>
            <returns>An empty map object.</returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumReader`1.MapAccess.AddElements(System.Object,System.Int32,Avro.Generic.PreresolvingDatumReader{`0}.ReadItem,Avro.IO.Decoder,System.Boolean)">
            <summary>
            Adds elements to the given map by reading values from the decoder.
            </summary>
            <param name="map">Map to add elements to.</param>
            <param name="elements">Number of elements to add.</param>
            <param name="itemReader">Delegate to read an item from the decoder.</param>
            <param name="decoder">Decoder to read from.</param>
            <param name="reuse">
            True to reuse each element in the map when deserializing. False to create a new
            object for each element.
            </param>
        </member>
        <member name="T:Avro.Generic.PreresolvingDatumWriter`1">
            <summary>
            A general purpose writer of data from avro streams. This writer analyzes the writer schema
            when constructed so that writes can be more efficient. Once constructed, a writer can be reused or shared among threads
            to avoid incurring more resolution costs.
            </summary>
        </member>
        <member name="P:Avro.Generic.PreresolvingDatumWriter`1.Schema">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Generic.PreresolvingDatumWriter`1.WriteItem">
            <summary>
            Defines the signature for a method that writes a value to an encoder.
            </summary>
            <param name="value">Value to write</param>
            <param name="encoder">Encoder to write to</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.Write(`0,Avro.IO.Encoder)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.#ctor(Avro.Schema,Avro.Generic.PreresolvingDatumWriter{`0}.ArrayAccess,Avro.Generic.PreresolvingDatumWriter{`0}.MapAccess)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Generic.PreresolvingDatumWriter`1"/> class.
            </summary>
            <param name="schema">Schema used by this writer</param>
            <param name="arrayAccess">Object used to access array properties</param>
            <param name="mapAccess">Object used to access map properties</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.WriteNull(System.Object,Avro.IO.Encoder)">
            <summary>
            Serializes a "null"
            </summary>
            <param name="value">The object to be serialized using null schema</param>
            <param name="encoder">The encoder to use while serialization</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.Write``1(System.Object,Avro.Schema.Type,Avro.Generic.Writer{``0})">
            <summary>
            A generic method to serialize primitive Avro types.
            </summary>
            <typeparam name="TValue">Type of the C# type to be serialized</typeparam>
            <param name="value">The value to be serialized</param>
            <param name="tag">The schema type tag</param>
            <param name="writer">The writer which should be used to write the given type.</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.ResolveRecord(Avro.RecordSchema)">
            <summary>
            Serializes a record using the given RecordSchema. It uses GetField method
            to extract the field value from the given object.
            </summary>
            <param name="recordSchema">The RecordSchema to use for serialization</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.WriteRecordFields(System.Object,Avro.Generic.PreresolvingDatumWriter{`0}.RecordFieldWriter[],Avro.IO.Encoder)">
            <summary>
            Writes each field of a record to the encoder.
            </summary>
            <param name="record">Record to write</param>
            <param name="writers">Writers for each field in the record</param>
            <param name="encoder">Encoder to write to</param>
        </member>
        <member name="T:Avro.Generic.PreresolvingDatumWriter`1.RecordFieldWriter">
            <summary>
            Correlates a record field with the writer used to serialize that field.
            </summary>
        </member>
        <member name="P:Avro.Generic.PreresolvingDatumWriter`1.RecordFieldWriter.WriteField">
            <summary>
            Delegate used to write the <see cref="P:Avro.Generic.PreresolvingDatumWriter`1.RecordFieldWriter.Field"/> to an encoder.
            </summary>
        </member>
        <member name="P:Avro.Generic.PreresolvingDatumWriter`1.RecordFieldWriter.Field">
            <summary>
            Field this object is associated with.
            </summary>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.EnsureRecordObject(Avro.RecordSchema,System.Object)">
            <summary>
            Ensures that the given value is a record and that it corresponds to the given schema.
            Throws an exception if either of those assertions are false.
            </summary>
            <param name="recordSchema">Schema associated with the record</param>
            <param name="value">Ensure this object is a record</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.WriteField(System.Object,System.String,System.Int32,Avro.Generic.PreresolvingDatumWriter{`0}.WriteItem,Avro.IO.Encoder)">
            <summary>
            Writes a field from the <paramref name="record"/> to the <paramref name="encoder"/>
            using the <paramref name="writer"/>.
            </summary>
            <param name="record">The record value from which the field needs to be extracted</param>
            <param name="fieldName">The name of the field in the record</param>
            <param name="fieldPos">The position of field in the record</param>
            <param name="writer">Used to write the field value to the encoder</param>
            <param name="encoder">Encoder to write to</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.ResolveEnum(Avro.EnumSchema)">
            <summary>
            Serializes an enumeration.
            </summary>
            <param name="es">The EnumSchema for serialization</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.ResolveArray(Avro.ArraySchema)">
            <summary>
            Creates a <see cref="T:Avro.Generic.PreresolvingDatumWriter`1.WriteItem"/> delegate that serializes an array.
            The default implementation calls EnsureArrayObject() to ascertain that the
            given value is an array. It then calls GetArrayLength() and GetArrayElement()
            to access the members of the array and then serialize them.
            </summary>
            <param name="schema">The ArraySchema for serialization</param>
            <returns>A <see cref="T:Avro.Generic.PreresolvingDatumWriter`1.WriteItem"/> that serializes an array.</returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.ResolveLogical(Avro.LogicalSchema)">
            <summary>
            Serializes a logical value object by using the underlying logical type to convert the value
            to its base value.
            </summary>
            <param name="schema">The logical schema.</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.WriteMap(Avro.Generic.PreresolvingDatumWriter{`0}.WriteItem,System.Object,Avro.IO.Encoder)">
            <summary>
            Serializes a map. The default implementation first ensure that the value is indeed a map and then uses
            GetMapSize() and GetMapElements() to access the contents of the map.
            </summary>
            <param name="itemWriter">Delegate used to write each map item.</param>
            <param name="value">The value to be serialized</param>
            <param name="encoder">The encoder for serialization</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.WriteUnion(Avro.UnionSchema,Avro.Schema[],Avro.Generic.PreresolvingDatumWriter{`0}.WriteItem[],System.Object,Avro.IO.Encoder)">
            <summary>
            Resolves the given value against the given UnionSchema and serializes the object against
            the resolved schema member.
            </summary>
            <param name="unionSchema">The UnionSchema to resolve against</param>
            <param name="branchSchemas">Schemas for each type in the union</param>
            <param name="branchWriters">Writers for each type in the union</param>
            <param name="value">The value to be serialized</param>
            <param name="encoder">The encoder for serialization</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.ResolveUnion(Avro.UnionSchema,Avro.Schema[],System.Object)">
            <summary>
            Finds the branch within the given UnionSchema that matches the given object. The default implementation
            calls Matches() method in the order of branches within the UnionSchema. If nothing matches, throws
            an exception.
            </summary>
            <param name="us">The UnionSchema to resolve against</param>
            <param name="branchSchemas">Schemas for types within the union</param>
            <param name="obj">The object that should be used in matching</param>
            <returns>
            Index of the schema in <paramref name="branchSchemas"/> that matches the <paramref name="obj"/>.
            </returns>
            <exception cref="T:Avro.AvroException">
            No match found for the object in the union schema.
            </exception>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.WriteFixed(Avro.FixedSchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Serialized a fixed object. The default implementation requires that the value is
            a GenericFixed object with an identical schema as es.
            </summary>
            <param name="es">The schema for serialization</param>
            <param name="value">The value to be serialized</param>
            <param name="encoder">The encoder for serialization</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.TypeMismatch(System.Object,System.String,System.String)">
            <summary>
            Creates a new <see cref="T:Avro.AvroException"/> and uses the provided parameters to build an
            exception message indicathing there was a type mismatch.
            </summary>
            <param name="obj">Object whose type does not the expected type</param>
            <param name="schemaType">Schema that we tried to write against</param>
            <param name="type">Type that we expected</param>
            <returns>A new <see cref="T:Avro.AvroException"/> indicating a type mismatch.</returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.UnionBranchMatches(Avro.Schema,System.Object)">
            <summary>
            Tests whether the given schema an object are compatible.
            </summary>
            <param name="sc">Schema to compare</param>
            <param name="obj">Object to compare</param>
            <returns>True if the two parameters are compatible, false otherwise.</returns>
        </member>
        <member name="T:Avro.Generic.PreresolvingDatumWriter`1.EnumAccess">
            <summary>
            Obsolete - This will be removed from the public API in a future version.
            </summary>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.EnumAccess.WriteEnum(System.Object)">
            <summary>
            Obsolete - This will be removed from the public API in a future version.
            </summary>
        </member>
        <member name="T:Avro.Generic.PreresolvingDatumWriter`1.ArrayAccess">
            <summary>
            Defines the interface for a class that provides access to an array implementation.
            </summary>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.ArrayAccess.EnsureArrayObject(System.Object)">
            <summary>
            Checks if the given object is an array. If it is a valid array, this function returns normally. Otherwise,
            it throws an exception. The default implementation checks if the value is an array.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.ArrayAccess.GetArrayLength(System.Object)">
            <summary>
            Returns the length of an array. The default implementation requires the object
            to be an array of objects and returns its length. The defaul implementation
            gurantees that EnsureArrayObject() has been called on the value before this
            function is called.
            </summary>
            <param name="value">The object whose array length is required</param>
            <returns>The array length of the given object</returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.ArrayAccess.WriteArrayValues(System.Object,Avro.Generic.PreresolvingDatumWriter{`0}.WriteItem,Avro.IO.Encoder)">
            <summary>
            Writes each value in the given array to the <paramref name="encoder"/> using the
            <paramref name="valueWriter"/>. The default implementation of this method requires
            that the <paramref name="array"/> is an object array.
            </summary>
            <param name="array">The array object</param>
            <param name="valueWriter">Value writer to send the array to.</param>
            <param name="encoder">Encoder to the write the array values to.</param>
        </member>
        <member name="T:Avro.Generic.PreresolvingDatumWriter`1.MapAccess">
            <summary>
            Defines the interface for a class that provides access to a map implementation.
            </summary>
            <seealso cref="T:Avro.Generic.PreresolvingDatumWriter`1.DictionaryMapAccess"/>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.MapAccess.EnsureMapObject(System.Object)">
            <summary>
            Checks if the given object is a map. If it is a valid map, this function returns normally. Otherwise,
            it throws an exception. The default implementation checks if the value is an IDictionary&lt;string, object&gt;.
            </summary>
            <param name="value">Ensures that this object is a valid map.</param>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.MapAccess.GetMapSize(System.Object)">
            <summary>
            Returns the size of the map object. The default implementation gurantees that EnsureMapObject has been
            successfully called with the given value. The default implementation requires the value
            to be an IDictionary&lt;string, object&gt; and returns the number of elements in it.
            </summary>
            <param name="value">The map object whose size is desired</param>
            <returns>The size of the given map object</returns>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.MapAccess.WriteMapValues(System.Object,Avro.Generic.PreresolvingDatumWriter{`0}.WriteItem,Avro.IO.Encoder)">
            <summary>
            Writes each value in the given map to the <paramref name="encoder"/> using the
            <paramref name="valueWriter"/>. The default implementation of this method requires
            that the <paramref name="map"/> is an IDictionary&lt;string, object&gt;.
            </summary>
            <param name="map">Map object to write the contents of.</param>
            <param name="valueWriter">Value writer to send the map to.</param>
            <param name="encoder">Encoder to the write the map values to.</param>
        </member>
        <member name="T:Avro.Generic.PreresolvingDatumWriter`1.DictionaryMapAccess">
            <summary>
            Provides access to map properties from an <see cref="T:System.Collections.IDictionary"/>.
            </summary>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.DictionaryMapAccess.EnsureMapObject(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.DictionaryMapAccess.GetMapSize(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Generic.PreresolvingDatumWriter`1.DictionaryMapAccess.WriteMapValues(System.Object,Avro.Generic.PreresolvingDatumWriter{`0}.WriteItem,Avro.IO.Encoder)">
            <inheritdoc/>
        </member>
        <member name="T:Avro.IO.BinaryDecoder">
            <summary>
            Decoder for Avro binary format
            </summary>
            <content>
            Contains the netstandard2.0 specific functionality for BinaryDecoder.
            </content>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.IO.BinaryDecoder"/> class.
            </summary>
            <param name="stream">Stream to decode.</param>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadNull">
            <summary>
            null is written as zero bytes
            </summary>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadBoolean">
            <summary>
            a boolean is written as a single byte
            whose value is either 0 (false) or 1 (true).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadInt">
            <summary>
            int and long values are written using variable-length, zig-zag coding.
            </summary>
            <returns>An integer value.</returns>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadLong">
            <summary>
            int and long values are written using variable-length, zig-zag coding.
            </summary>
            <returns>A long value.</returns>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadBytes">
            <summary>
            Bytes are encoded as a long followed by that many bytes of data.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadEnum">
            <summary>
            Reads an enumeration.
            </summary>
            <returns>Ordinal value of the enum.</returns>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadArrayStart">
            <summary>
            Reads the size of the first block of an array.
            </summary>
            <returns>Size of the first block of an array.</returns>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadArrayNext">
            <summary>
            Processes the next block of an array and returns the number of items in the block and
            let's the caller read those items.
            </summary>
            <returns>Number of items in the next block of an array.</returns>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadMapStart">
            <summary>
            Reads the size of the next block of map-entries.
            </summary>
            <returns>Size of the next block of map-entries.</returns>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadMapNext">
            <summary>
            Processes the next block of map entries and returns the count of them.
            </summary>
            <returns>Number of entires in the next block of a map.</returns>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadUnionIndex">
            <summary>
            Reads the tag index of a union written by <see cref="M:Avro.IO.BinaryEncoder.WriteUnionIndex(System.Int32)"/>.
            </summary>
            <returns>Tag index of a union.</returns>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadFixed(System.Byte[])">
            <summary>
            Reads fixed sized binary object.
            </summary>
            <param name="buffer">Buffer to read the fixed value into.</param>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadFixed(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads fixed sized binary object.
            </summary>
            <param name="buffer">Buffer to read the fixed value into.</param>
            <param name="start">
            Position to start writing the fixed value to in the <paramref name="buffer"/>.
            </param>
            <param name="length">
            Number of bytes of the fixed to read.
            </param>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.SkipNull">
            <summary>
            Skips over a null value.
            </summary>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.SkipBoolean">
            <summary>
            Skips over a boolean value.
            </summary>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.SkipInt">
            <summary>
            Skips over an int value.
            </summary>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.SkipLong">
            <summary>
            Skips over a long value.
            </summary>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.SkipFloat">
            <summary>
            Skips over a float value.
            </summary>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.SkipDouble">
            <summary>
            Skips over a double value.
            </summary>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.SkipBytes">
            <summary>
            Skips a byte-string written by <see cref="M:Avro.IO.BinaryEncoder.WriteBytes(System.Byte[])"/>.
            </summary>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.SkipString">
            <summary>
            Skips a string written by <see cref="M:Avro.IO.BinaryEncoder.WriteString(System.String)"/>.
            </summary>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.SkipEnum">
            <summary>
            Skips an enum value.
            </summary>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.SkipUnionIndex">
            <summary>
            Skips a union tag index.
            </summary>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.SkipFixed(System.Int32)">
            <summary>
            Skips a fixed value of a specified length.
            </summary>
            <param name="len">Length of the fixed to skip.</param>
        </member>
        <member name="F:Avro.IO.BinaryDecoder.MaxDotNetArrayLength">
            <summary>
            It is hard to find documentation about the real maximum array length in .NET Framework 4.6.1, but this seems to work :-/
            </summary>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadFloat">
            <summary>
            A float is written as 4 bytes.
            The float is converted into a 32-bit integer using a method equivalent to
            Java's floatToIntBits and then encoded in little-endian format.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadDouble">
            <summary>
            A double is written as 8 bytes.
            The double is converted into a 64-bit integer using a method equivalent to
            Java's doubleToLongBits and then encoded in little-endian format.
            </summary>
            <returns>A double value.</returns>
        </member>
        <member name="M:Avro.IO.BinaryDecoder.ReadString">
            <summary>
            Reads a string written by <see cref="M:Avro.IO.BinaryEncoder.WriteString(System.String)"/>.
            </summary>
            <returns>String read from the stream.</returns>
        </member>
        <member name="T:Avro.IO.BinaryEncoder">
            <summary>
            Write leaf values.
            </summary>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.IO.BinaryEncoder"/> class without a backing
            stream.
            </summary>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.#ctor(System.IO.Stream)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.IO.BinaryEncoder"/> class that writes to
            the provided stream.
            </summary>
            <param name="stream">Stream to write to.</param>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteNull">
            <summary>
            null is written as zero bytes
            </summary>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteBoolean(System.Boolean)">
            <summary>
            true is written as 1 and false 0.
            </summary>
            <param name="b">Boolean value to write</param>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteInt(System.Int32)">
            <summary>
            int and long values are written using variable-length, zig-zag coding.
            </summary>
            <param name="value">Value to write</param>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteLong(System.Int64)">
            <summary>
            int and long values are written using variable-length, zig-zag coding.
            </summary>
            <param name="value">Value to write</param>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteFloat(System.Single)">
            <summary>
            A float is written as 4 bytes.
            The float is converted into a 32-bit integer using a method equivalent to
            Java's floatToIntBits and then encoded in little-endian format.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteDouble(System.Double)">
             <summary>
            A double is written as 8 bytes.
            The double is converted into a 64-bit integer using a method equivalent to
            Java's doubleToLongBits and then encoded in little-endian format.
             </summary>
             <param name="value"></param>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteBytes(System.Byte[])">
            <summary>
            Bytes are encoded as a long followed by that many bytes of data.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Bytes are encoded as a long followed by that many bytes of data.
            </summary>
            <param name="value">The byte[] to be read (fully or partially)</param>
            <param name="offset">The offset from the beginning of the byte[] to start writing</param>
            <param name="length">The length of the data to be read from the byte[].</param>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteString(System.String)">
            <summary>
            A string is encoded as a long followed by
            that many bytes of UTF-8 encoded character data.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteEnum(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.StartItem">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.SetItemCount(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteArrayStart">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteArrayEnd">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteMapStart">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteMapEnd">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteUnionIndex(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteFixed(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.WriteFixed(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.BinaryEncoder.Flush">
            <summary>
            Flushes the underlying stream.
            </summary>
        </member>
        <member name="T:Avro.IO.ByteBufferInputStream">
            <summary>
            Utility to present <see cref="T:System.IO.MemoryStream"/>s as an <see cref="T:Avro.IO.InputStream"/>.
            </summary>
            <seealso cref="T:Avro.IO.ByteBufferOutputStream"/>
        </member>
        <member name="M:Avro.IO.ByteBufferInputStream.#ctor(System.Collections.Generic.IList{System.IO.MemoryStream})">
            <summary>
            Initializes a new instance of a <see cref="T:Avro.IO.ByteBufferInputStream"/>.
            </summary>
            <param name="buffers"></param>
        </member>
        <member name="M:Avro.IO.ByteBufferInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Avro.IO.ByteBufferInputStream.Length">
            <summary>
            Throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">
            Always thows.
            </exception>
        </member>
        <member name="T:Avro.IO.ByteBufferOutputStream">
            <summary>
            Utility to collect data written to an <see cref="T:Avro.IO.OutputStream"/> in
            <see cref="T:System.IO.MemoryStream"/>s.
            </summary>
            <seealso cref="T:Avro.IO.ByteBufferInputStream"/>
        </member>
        <member name="F:Avro.IO.ByteBufferOutputStream.BUFFER_SIZE">
            <summary>
            Size of memory stream buffers.
            </summary>
        </member>
        <member name="M:Avro.IO.ByteBufferOutputStream.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.IO.ByteBufferOutputStream"/> class.
            </summary>
        </member>
        <member name="M:Avro.IO.ByteBufferOutputStream.Prepend(System.Collections.Generic.List{System.IO.MemoryStream})">
            <summary>
            Prepends a list of <see cref="T:System.IO.MemoryStream"/> to this stream.
            </summary>
            <param name="lists">Memory streams to prepend.</param>
        </member>
        <member name="M:Avro.IO.ByteBufferOutputStream.Append(System.Collections.Generic.List{System.IO.MemoryStream})">
            <summary>
            Appends a list of <see cref="T:System.IO.MemoryStream"/> to this stream.
            </summary>
            <param name="lists">Memory streams to append.</param>
        </member>
        <member name="M:Avro.IO.ByteBufferOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.ByteBufferOutputStream.GetBufferList">
            <summary>
            Returns all data written and resets the stream to be empty.
            </summary>
            <returns>All memory stream data.</returns>
        </member>
        <member name="P:Avro.IO.ByteBufferOutputStream.Length">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.ByteBufferOutputStream.Flush">
            <inheritdoc/>
        </member>
        <member name="T:Avro.IO.Decoder">
            <summary>
            Decoder is used to decode Avro data on a stream. There are methods to read the Avro types on the stream. There are also
            methods to skip items, which are usually more efficient than reading, on the stream.
            </summary>
        </member>
        <member name="M:Avro.IO.Decoder.ReadNull">
            <summary>
            Reads a null Avro type.
            </summary>
        </member>
        <member name="M:Avro.IO.Decoder.ReadBoolean">
            <summary>
            Read a boolean Avro type
            </summary>
            <returns>The boolean just read</returns>
        </member>
        <member name="M:Avro.IO.Decoder.ReadInt">
            <summary>
            Reads an int Avro type.
            </summary>
            <returns>The int just read</returns>
        </member>
        <member name="M:Avro.IO.Decoder.ReadLong">
            <summary>
            Reads a long Avro type.
            </summary>
            <returns>The long just read</returns>
        </member>
        <member name="M:Avro.IO.Decoder.ReadFloat">
            <summary>
            Reads a float Avro type
            </summary>
            <returns>The float just read</returns>
        </member>
        <member name="M:Avro.IO.Decoder.ReadDouble">
            <summary>
            Reads a double Avro type
            </summary>
            <returns>The double just read</returns>
        </member>
        <member name="M:Avro.IO.Decoder.ReadBytes">
            <summary>
            Reads the bytes Avro type
            </summary>
            <returns>The bytes just read</returns>
        </member>
        <member name="M:Avro.IO.Decoder.ReadString">
            <summary>
            Reads a string Avro type
            </summary>
            <returns>The string just read</returns>
        </member>
        <member name="M:Avro.IO.Decoder.ReadEnum">
            <summary>
            Reads an enum AvroType
            </summary>
            <returns>The enum just read</returns>
        </member>
        <member name="M:Avro.IO.Decoder.ReadArrayStart">
             <summary>
             Starts reading the array Avro type. This, together with ReadArrayNext() is used to read the
             items from Avro array. This returns the number of entries in the initial chunk. After consuming
             the chunk, the client should call ReadArrayNext() to get the number of entries in the next
             chunk. The client should repeat the procedure until there are no more entries in the array.
            
             for (int n = decoder.ReadArrayStart(); n > 0; n = decoder.ReadArrayNext())
             {
                 // Read one array entry.
             }
             </summary>
             <returns>The number of entries in the initial chunk, 0 if the array is empty.</returns>
        </member>
        <member name="M:Avro.IO.Decoder.ReadArrayNext">
            <summary>
            See ReadArrayStart().
            </summary>
            <returns>The number of array entries in the next chunk, 0 if there are no more entries.</returns>
        </member>
        <member name="M:Avro.IO.Decoder.ReadMapStart">
            <summary>
            Starts reading the map Avro type. This, together with ReadMapNext() is used to read the
            entries from Avro map. This returns the number of entries in the initial chunk. After consuming
            the chunk, the client should call ReadMapNext() to get the number of entriess in the next
            chunk. The client should repeat the procedure until there are no more entries in the array.
            for (int n = decoder.ReadMapStart(); n > 0; n = decoder.ReadMapNext())
            {
                // Read one map entry.
            }
            </summary>
            <returns>The number of entries in the initial chunk, 0 if the map is empty.</returns>
        </member>
        <member name="M:Avro.IO.Decoder.ReadMapNext">
            <summary>
            See ReadMapStart().
            </summary>
            <returns>The number of map entries in the next chunk, 0 if there are no more entries.</returns>
        </member>
        <member name="M:Avro.IO.Decoder.ReadUnionIndex">
            <summary>
            Reads the index, which determines the type in an union Avro type.
            </summary>
            <returns>The index of the type within the union.</returns>
        </member>
        <member name="M:Avro.IO.Decoder.ReadFixed(System.Byte[])">
            <summary>
            A convenience method for ReadFixed(buffer, 0, buffer.Length);
            </summary>
            <param name="buffer"> The buffer to read into.</param>
        </member>
        <member name="M:Avro.IO.Decoder.ReadFixed(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a Fixed Avro type of length.
            </summary>
            <param name="buffer">Buffer to read into</param>
            <param name="start">Starting position of buffer to read into</param>
            <param name="length">Number of bytes to read</param>
        </member>
        <member name="M:Avro.IO.Decoder.SkipNull">
            <summary>
            Skips a null Avro type on the stream.
            </summary>
        </member>
        <member name="M:Avro.IO.Decoder.SkipBoolean">
            <summary>
             Skips a boolean Avro type on the stream.
            </summary>
        </member>
        <member name="M:Avro.IO.Decoder.SkipInt">
            <summary>
             Skips a int Avro type on the stream.
            </summary>
        </member>
        <member name="M:Avro.IO.Decoder.SkipLong">
            <summary>
             Skips a long Avro type on the stream.
            </summary>
        </member>
        <member name="M:Avro.IO.Decoder.SkipFloat">
            <summary>
            Skips a float Avro type on the stream.
            </summary>
        </member>
        <member name="M:Avro.IO.Decoder.SkipDouble">
            <summary>
            Skips a double Avro type on the stream.
            </summary>
        </member>
        <member name="M:Avro.IO.Decoder.SkipBytes">
            <summary>
            Skips a bytes Avro type on the stream.
            </summary>
        </member>
        <member name="M:Avro.IO.Decoder.SkipString">
            <summary>
            Skips a string Avro type on the stream.
            </summary>
        </member>
        <member name="M:Avro.IO.Decoder.SkipEnum">
            <summary>
            Skips an enumeration.
            </summary>
        </member>
        <member name="M:Avro.IO.Decoder.SkipUnionIndex">
            <summary>
            Skips a union tag index.
            </summary>
        </member>
        <member name="M:Avro.IO.Decoder.SkipFixed(System.Int32)">
            <summary>
            Skips a fixed of a specified length.
            </summary>
            <param name="len">Length of the fixed.</param>
        </member>
        <member name="T:Avro.IO.Encoder">
            <summary>
            Defines the interface for a class that provies low-level support for serializing Avro
            values.
            </summary>
        </member>
        <member name="M:Avro.IO.Encoder.WriteNull">
            <summary>
            Writes a null value.
            </summary>
        </member>
        <member name="M:Avro.IO.Encoder.WriteBoolean(System.Boolean)">
            <summary>
            Writes a boolean value.
            </summary>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:Avro.IO.Encoder.WriteInt(System.Int32)">
            <summary>
            Writes an int value.
            </summary>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:Avro.IO.Encoder.WriteLong(System.Int64)">
            <summary>
            Writes a long value.
            </summary>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:Avro.IO.Encoder.WriteFloat(System.Single)">
            <summary>
            Writes a float value.
            </summary>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:Avro.IO.Encoder.WriteDouble(System.Double)">
            <summary>
            Writes a double value.
            </summary>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:Avro.IO.Encoder.WriteBytes(System.Byte[])">
            <summary>
            Writes a byte string.
            </summary>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:Avro.IO.Encoder.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a byte string.
            </summary>
            <param name="value">The byte[] to be read (fully or partially)</param>
            <param name="offset">The offset from the beginning of the byte[] to start writing</param>
            <param name="length">The length of the data to be read from the byte[].</param>
        </member>
        <member name="M:Avro.IO.Encoder.WriteString(System.String)">
            <summary>
            Writes an Unicode string.
            </summary>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:Avro.IO.Encoder.WriteEnum(System.Int32)">
            <summary>
            Writes an enumeration.
            </summary>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:Avro.IO.Encoder.SetItemCount(System.Int64)">
            <summary>
            Call this method before writing a batch of items in an array or a map.
            </summary>
            <param name="value">Number of <see cref="M:Avro.IO.Encoder.StartItem"/> calls to follow.</param>
        </member>
        <member name="M:Avro.IO.Encoder.StartItem">
            <summary>
            Start a new item of an array or map. See <see cref="M:Avro.IO.Encoder.WriteArrayStart"/> for usage
            information.
            </summary>
        </member>
        <member name="M:Avro.IO.Encoder.WriteArrayStart">
            <summary>
            Call this method to start writing an array. When starting to serialize an array, call
            <see cref="M:Avro.IO.Encoder.WriteArrayStart"/>. Then, before writing any data for any item call
            <see cref="M:Avro.IO.Encoder.SetItemCount(System.Int64)"/> followed by a sequence of <see cref="M:Avro.IO.Encoder.StartItem"/> and
            the item itself. The number of <see cref="M:Avro.IO.Encoder.StartItem"/> should match the number specified
            in <see cref="M:Avro.IO.Encoder.SetItemCount(System.Int64)"/>. When actually writing the data of the item, you can
            call any <see cref="T:Avro.IO.Encoder"/> method (e.g., <see cref="M:Avro.IO.Encoder.WriteLong(System.Int64)"/>). When all
            items of the array have been written, call <see cref="M:Avro.IO.Encoder.WriteArrayEnd"/>.
            <example>
            As an example, let's say you want to write an array of records, the record consisting
            of an Long field and a Boolean field. Your code would look something like this:
            <code>
            out.WriteArrayStart();
            out.SetItemCount(list.Count);
            foreach (var r in list)
            {
                out.StartItem();
                out.WriteLong(r.LongField);
                out.WriteBoolean(r.BoolField);
            }
            out.WriteArrayEnd();
            </code>
            </example>
            </summary>
        </member>
        <member name="M:Avro.IO.Encoder.WriteArrayEnd">
            <summary>
            Call this method to finish writing an array. See <see cref="M:Avro.IO.Encoder.WriteArrayStart"/> for usage
            information.
            </summary>
        </member>
        <member name="M:Avro.IO.Encoder.WriteMapStart">
            <summary>
            Call this to start a new map. See <see cref="M:Avro.IO.Encoder.WriteArrayStart"/> for details on usage.
            <example>
            As an example of usage, let's say you want to write a map of records, the record
            consisting of an Long field and a Boolean field. Your code would look something like
            this:
            <code>
            out.WriteMapStart();
            out.SetItemCount(dictionary.Count);
            foreach (var entry in dictionary)
            {
                out.StartItem();
                out.WriteString(entry.Key);
                out.writeLong(entry.Value.LongField);
                out.writeBoolean(entry.Value.BoolField);
            }
            out.WriteMapEnd();
            </code>
            </example>
            </summary>
        </member>
        <member name="M:Avro.IO.Encoder.WriteMapEnd">
            <summary>
            Call this method to terminate the inner-most, currently-opened map. See
            <see cref="M:Avro.IO.Encoder.WriteArrayStart"/> for more details.
            </summary>
        </member>
        <member name="M:Avro.IO.Encoder.WriteUnionIndex(System.Int32)">
            <summary>
            Call this method to write the tag of a union.
            <example>
            As an example of usage, let's say you want to write a union, whose second branch is a
            record consisting of an Long field and a Boolean field. Your code would look something
            like this:
            <code>
            out.WriteIndex(1);
            out.WriteLong(record.LongField);
            out.WriteBoolean(record.BoolField);
            </code>
            </example>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Avro.IO.Encoder.WriteFixed(System.Byte[])">
            <summary>
            Writes a fixed value.
            </summary>
            <param name="data">The contents to write.</param>
        </member>
        <member name="M:Avro.IO.Encoder.WriteFixed(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a fixed value.
            </summary>
            <param name="data">Contents to write.</param>
            <param name="start">Position within data where the contents start.</param>
            <param name="len">Number of bytes to write.</param>
        </member>
        <member name="T:Avro.IO.ICallback`1">
            <summary>
            Obsolete - This will be removed from the public API in a future version.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Avro.IO.ICallback`1.HandleResult(`0)">
            <summary>
            Receives a callback result.
            </summary>
            <param name="result">Result returned in the callback.</param>
        </member>
        <member name="M:Avro.IO.ICallback`1.HandleException(System.Exception)">
            <summary>
            Receives an error.
            </summary>
            <param name="exception">Error returned in the callback.</param>
        </member>
        <member name="T:Avro.IO.InputStream">
            <summary>
            Base class for an input stream.
            </summary>
            <seealso cref="T:Avro.IO.OutputStream"/>
        </member>
        <member name="M:Avro.IO.InputStream.Flush">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.InputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.InputStream.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.InputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:Avro.IO.InputStream.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Avro.IO.InputStream.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:Avro.IO.InputStream.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Avro.IO.InputStream.Position">
            <inheritdoc/>
        </member>
        <member name="T:Avro.IO.OutputStream">
            <summary>
            Base class for an output stream.
            </summary>
            <seealso cref="T:Avro.IO.InputStream"/>
        </member>
        <member name="P:Avro.IO.OutputStream.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:Avro.IO.OutputStream.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:Avro.IO.OutputStream.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:Avro.IO.OutputStream.Position">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.OutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.OutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.OutputStream.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.IO.Resolver.EncodeDefaultValue(Avro.IO.Encoder,Avro.Schema,Newtonsoft.Json.Linq.JToken)">
            <summary>
            Reads the passed JToken default value field and writes it in the specified encoder
            </summary>
            <param name="enc">encoder to use for writing</param>
            <param name="schema">schema object for the current field</param>
            <param name="jtok">default value as JToken</param>
        </member>
        <member name="T:Avro.Message">
            <summary>
            Represents a message in an Avro protocol.
            </summary>
        </member>
        <member name="P:Avro.Message.Name">
            <summary>
            Name of the message
            </summary>
        </member>
        <member name="P:Avro.Message.Doc">
            <summary>
            Documentation for the message
            </summary>
        </member>
        <member name="P:Avro.Message.Request">
            <summary>
            Anonymous record for the list of parameters for the request fields
            </summary>
        </member>
        <member name="P:Avro.Message.Response">
            <summary>
            Schema object for the 'response' attribute
            </summary>
        </member>
        <member name="P:Avro.Message.Error">
            <summary>
            Union schema object for the 'error' attribute
            </summary>
        </member>
        <member name="P:Avro.Message.Oneway">
            <summary>
            Optional one-way attribute
            </summary>
        </member>
        <member name="P:Avro.Message.SupportedErrors">
            <summary>
            Explicitly defined protocol errors plus system added "string" error
            </summary>
        </member>
        <member name="M:Avro.Message.#ctor(System.String,System.String,Avro.RecordSchema,Avro.Schema,Avro.UnionSchema,System.Nullable{System.Boolean})">
            <summary>
            Constructor for Message class
            </summary>
            <param name="name">name property</param>
            <param name="doc">doc property</param>
            <param name="request">list of parameters</param>
            <param name="response">response property</param>
            <param name="error">error union schema</param>
            <param name="oneway">
            Indicates that this is a one-way message. This may only be true when
            <paramref name="response"/> is <see cref="F:Avro.Schema.Type.Null"/> and there are no errors
            listed.
            </param>
        </member>
        <member name="M:Avro.Message.Parse(Newtonsoft.Json.Linq.JProperty,Avro.SchemaNames,System.String)">
            <summary>
            Parses the messages section of a protocol definition
            </summary>
            <param name="jmessage">messages JSON object</param>
            <param name="names">list of parsed names</param>
            <param name="encspace">enclosing namespace</param>
            <returns></returns>
        </member>
        <member name="M:Avro.Message.writeJson(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames,System.String)">
            <summary>
            Writes the messages section of a protocol definition
            </summary>
            <param name="writer">writer</param>
            <param name="names">list of names written</param>
            <param name="encspace">enclosing namespace</param>
        </member>
        <member name="M:Avro.Message.Equals(System.Object)">
            <summary>
            Tests equality of this Message object with the passed object
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.Message.GetHashCode">
            <summary>
            Returns the hash code of this Message object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.Message.areEqual(System.Object,System.Object)">
            <summary>
            Tests equality of two objects taking null values into account
            </summary>
            <param name="o1"></param>
            <param name="o2"></param>
            <returns></returns>
        </member>
        <member name="T:Avro.Protocol">
            <summary>
            A set of messages forming an application protocol.
            </summary>
        </member>
        <member name="P:Avro.Protocol.Name">
            <summary>
            Name of the protocol
            </summary>
        </member>
        <member name="P:Avro.Protocol.Namespace">
            <summary>
            Namespace of the protocol
            </summary>
        </member>
        <member name="P:Avro.Protocol.Doc">
            <summary>
            Documentation for the protocol
            </summary>
        </member>
        <member name="P:Avro.Protocol.Types">
            <summary>
            List of schemas objects representing the different schemas defined under the 'types' attribute
            </summary>
        </member>
        <member name="P:Avro.Protocol.Messages">
            <summary>
            List of message objects representing the different schemas defined under the 'messages' attribute
            </summary>
        </member>
        <member name="P:Avro.Protocol.MD5">
            <summary>
            MD5 hash of the text of this protocol.
            </summary>
        </member>
        <member name="M:Avro.Protocol.#ctor(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Avro.Schema},System.Collections.Generic.IDictionary{System.String,Avro.Message})">
            <summary>
            Constructor for Protocol class
            </summary>
            <param name="name">required name of protocol</param>
            <param name="space">optional namespace</param>
            <param name="doc">optional documentation</param>
            <param name="types">required list of types</param>
            <param name="messages">required list of messages</param>
        </member>
        <member name="M:Avro.Protocol.Parse(System.String)">
            <summary>
            Parses the given JSON string to create a Protocol object
            </summary>
            <param name="jstring">JSON string</param>
            <returns>Protocol object</returns>
        </member>
        <member name="M:Avro.Protocol.Parse(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Parses the given JSON object to create a Protocol object
            </summary>
            <param name="jtok">JSON object</param>
            <returns>Protocol object</returns>
        </member>
        <member name="M:Avro.Protocol.ToString">
            <summary>
            Writes Protocol in JSON format
            </summary>
            <returns>JSON string</returns>
        </member>
        <member name="M:Avro.Protocol.WriteJson(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames)">
            <summary>
            Writes Protocol in JSON format
            </summary>
            <param name="writer">JSON writer</param>
            <param name="names">list of named schemas already written</param>
        </member>
        <member name="M:Avro.Protocol.Equals(System.Object)">
            <summary>
            Tests equality of this protocol object with the passed object
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.Protocol.TypesEquals(System.Collections.Generic.IList{Avro.Schema})">
            <summary>
            Test equality of this protocols Types list with the passed Types list.
            Order of schemas does not matter, as long as all types in this protocol
            are also defined in the passed protocol
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.Protocol.MessagesEquals(System.Collections.Generic.IDictionary{System.String,Avro.Message})">
            <summary>
            Test equality of this protocols Message map with the passed Message map
            Order of messages does not matter, as long as all messages in this protocol
            are also defined in the passed protocol
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.Protocol.GetHashCode">
            <summary>
            Returns the hash code of this protocol object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.Protocol.GetTypesHashCode">
            <summary>
            Returns the hash code of the Types list
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.Protocol.GetMessagesHashCode">
            <summary>
            Returns the hash code of the Messages map
            </summary>
            <returns></returns>
        </member>
        <member name="T:Avro.ProtocolParseException">
            <summary>
            Used to communicate an exception that occurred while parsing a protocol.
            </summary>
        </member>
        <member name="M:Avro.ProtocolParseException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.ProtocolParseException"/> class.
            </summary>
        </member>
        <member name="M:Avro.ProtocolParseException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.ProtocolParseException"/> class.
            </summary>
            <param name="s">Exception message.</param>
        </member>
        <member name="M:Avro.ProtocolParseException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.ProtocolParseException"/> class.
            </summary>
            <param name="s">Exception message.</param>
            <param name="inner">
            The exception that is the cause of the current exception, or a null reference
            if no inner exception is specified.
            </param>
        </member>
        <member name="T:Avro.Reflect.ArrayHelper">
            <summary>
            Class to help serialize and deserialize arrays. Arrays need the following methods Count(), Add(), Clear().true
            This class allows these methods to be specified externally to the collection.
            </summary>
        </member>
        <member name="P:Avro.Reflect.ArrayHelper.DefaultType">
            <summary>
            Collection type to apply by default to all array objects. If not set this defaults to a generic List.
            </summary>
        </member>
        <member name="P:Avro.Reflect.ArrayHelper.Enumerable">
            <summary>
            The array
            </summary>
        </member>
        <member name="M:Avro.Reflect.ArrayHelper.Count">
            <summary>
            Return the number of elements in the array.
            </summary>
            <value></value>
        </member>
        <member name="M:Avro.Reflect.ArrayHelper.Add(System.Object)">
            <summary>
            Add an element to the array.
            </summary>
            <param name="o">Element to add to the array.</param>
        </member>
        <member name="M:Avro.Reflect.ArrayHelper.Clear">
            <summary>
            Clear the array.
            </summary>
            <value></value>
        </member>
        <member name="P:Avro.Reflect.ArrayHelper.ArrayType">
            <summary>
            Type of the array to create when deserializing
            </summary>
        </member>
        <member name="M:Avro.Reflect.ArrayHelper.#ctor(System.Collections.IEnumerable)">
            <summary>
            Constructor
            </summary>
            <param name="enumerable">Enumerable to initialize this helper with.</param>
        </member>
        <member name="T:Avro.Reflect.ArraySchemaExtensions">
            <summary>
            Extension methods for ArraySchema - make helper metadata look more like a property
            </summary>
        </member>
        <member name="M:Avro.Reflect.ArraySchemaExtensions.GetHelper(Avro.ArraySchema)">
            <summary>
            Return the name of the array helper
            </summary>
            <param name="ars">this</param>
            <returns>value of the helper metadata - null if it isnt present</returns>
        </member>
        <member name="T:Avro.Reflect.AvroFieldAttribute">
            <summary>
            Attribute that specifies the mapping between an Avro field and C# class property.
            </summary>
        </member>
        <member name="P:Avro.Reflect.AvroFieldAttribute.FieldName">
            <summary>
            Name of the field in the Avro Schema
            </summary>
        </member>
        <member name="P:Avro.Reflect.AvroFieldAttribute.Converter">
            <summary>
            Convert the property into a standard Avro type - e.g. DateTimeOffset to long
            </summary>
        </member>
        <member name="M:Avro.Reflect.AvroFieldAttribute.#ctor(System.String,System.Type)">
            <summary>
            Attribute to hold a field name and optionally a converter
            </summary>
            <param name="fieldName"></param>
            <param name="converter"></param>
        </member>
        <member name="M:Avro.Reflect.AvroFieldAttribute.#ctor(System.Type)">
            <summary>
            Used in property name mapping to specify a property type converter for the attribute.
            </summary>
            <param name="converter"></param>
        </member>
        <member name="T:Avro.Reflect.ClassCache">
            <summary>
            Class holds a cache of C# classes and their properties. The key for the cache is the schema full name.
            </summary>
        </member>
        <member name="M:Avro.Reflect.ClassCache.AddDefaultConverter(Avro.Reflect.IAvroFieldConverter)">
            <summary>
            Add a default field converter
            </summary>
            <param name="converter"></param>
        </member>
        <member name="M:Avro.Reflect.ClassCache.AddDefaultConverter``2(System.Func{``0,Avro.Schema,``1},System.Func{``1,Avro.Schema,``0})">
            <summary>
            Add a converter defined using Func&lt;&gt;. The converter will be used whenever the source and target types
            match and a specific attribute is not defined.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <typeparam name="TAvro"></typeparam>
            <typeparam name="TProperty"></typeparam>
        </member>
        <member name="M:Avro.Reflect.ClassCache.GetDefaultConverter(Avro.Schema.Type,System.Type)">
            <summary>
            Find a default converter
            </summary>
            <param name="tag"></param>
            <param name="propType"></param>
            <returns>The first matching converter - null if there isnt one</returns>
        </member>
        <member name="M:Avro.Reflect.ClassCache.AddArrayHelper(System.String,System.Type)">
            <summary>
            Add an array helper. Array helpers are used for collections that are not generic lists.
            </summary>
            <param name="name">Name of the helper. Corresponds to metadata "helper" field in the schema.</param>
            <param name="helperType">Type of helper. Inherited from ArrayHelper</param>
        </member>
        <member name="M:Avro.Reflect.ClassCache.GetArrayHelper(Avro.ArraySchema,System.Collections.IEnumerable)">
            <summary>
            Find an array helper for an array schema node.
            </summary>
            <param name="schema">Schema</param>
            <param name="enumerable">The array object. If it is null then Add(), Count() and Clear methods will throw exceptions.</param>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.ClassCache.GetClass(Avro.RecordSchema)">
            <summary>
            Find a class that matches the schema full name.
            </summary>
            <param name="schema"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.ClassCache.LoadClassCache(System.Type,Avro.Schema)">
            <summary>
            Add an entry to the class cache.
            </summary>
            <param name="objType">Type of the C# class</param>
            <param name="s">Schema</param>
        </member>
        <member name="T:Avro.Reflect.DateTimeOffsetToLongConverter">
            <summary>
            Convert C# DateTimeOffset properties to long unix time
            </summary>
        </member>
        <member name="M:Avro.Reflect.DateTimeOffsetToLongConverter.ToAvroType(System.Object,Avro.Schema)">
            <summary>
            Convert from DateTimeOffset to Unix long
            </summary>
            <param name="o">DateTimeOffset</param>
            <param name="s">Schema</param>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.DateTimeOffsetToLongConverter.FromAvroType(System.Object,Avro.Schema)">
            <summary>
            Convert from Unix long to DateTimeOffset
            </summary>
            <param name="o">long</param>
            <param name="s">Schema</param>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.DateTimeOffsetToLongConverter.GetAvroType">
            <summary>
            Avro type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.DateTimeOffsetToLongConverter.GetPropertyType">
            <summary>
            Property type
            </summary>
            <returns></returns>
        </member>
        <member name="T:Avro.Reflect.DotnetClass">
            <summary>
            Collection of DotNetProperty objects to repre
            </summary>
        </member>
        <member name="M:Avro.Reflect.DotnetClass.#ctor(System.Type,Avro.RecordSchema,Avro.Reflect.ClassCache)">
            <summary>
            Constructor
            </summary>
            <param name="t">type of the class</param>
            <param name="r">record schema</param>
            <param name="cache">class cache - can be reused</param>
        </member>
        <member name="M:Avro.Reflect.DotnetClass.GetValue(System.Object,Avro.Field)">
            <summary>
            Return the value of a property from an object referenced by a field
            </summary>
            <param name="o">the object</param>
            <param name="f">FieldSchema used to look up the property</param>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.DotnetClass.SetValue(System.Object,Avro.Field,System.Object)">
            <summary>
            Set the value of a property in a C# object
            </summary>
            <param name="o">the object</param>
            <param name="f">field schema</param>
            <param name="v">value for the proprty referenced by the field schema</param>
        </member>
        <member name="M:Avro.Reflect.DotnetClass.GetClassType">
            <summary>
            Return the type of the Class
            </summary>
            <returns>The </returns>
        </member>
        <member name="M:Avro.Reflect.DotnetClass.GetPropertyType(Avro.Field)">
            <summary>
            Return the type of a property referenced by a field
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="T:Avro.Reflect.EnumCache">
            <summary>
            Cache of enum types. Cache key is the schema fullname.
            </summary>
        </member>
        <member name="M:Avro.Reflect.EnumCache.AddEnumNameMapItem(Avro.NamedSchema,System.Type)">
            <summary>
            Add and entry to the cache
            </summary>
            <param name="schema"></param>
            <param name="dotnetEnum"></param>
        </member>
        <member name="M:Avro.Reflect.EnumCache.GetEnumeration(Avro.NamedSchema)">
            <summary>
            Lookup an entry in the cache - based on the schema fullname
            </summary>
            <param name="schema"></param>
            <returns></returns>
        </member>
        <member name="T:Avro.Reflect.FuncFieldConverter`2">
            <summary>
            Field converter using a Func
            </summary>
            <typeparam name="TAvro">Avro type</typeparam>
            <typeparam name="TProperty">Property type</typeparam>
        </member>
        <member name="M:Avro.Reflect.FuncFieldConverter`2.#ctor(System.Func{`0,Avro.Schema,`1},System.Func{`1,Avro.Schema,`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Reflect.FuncFieldConverter`2"/> class.
            </summary>
            <param name="from">Delegate to convert from C# type to Avro type</param>
            <param name="to">Delegate to convert from Avro type to C# type</param>
        </member>
        <member name="M:Avro.Reflect.FuncFieldConverter`2.From(`0,Avro.Schema)">
            <summary>
            Inherited conversion method - call the Func.
            </summary>
            <param name="o"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.FuncFieldConverter`2.To(`1,Avro.Schema)">
            <summary>
            Inherited conversion method - call the Func.
            </summary>
            <param name="o"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:Avro.Reflect.IAvroFieldConverter">
            <summary>
            Converters can be added to properties with an AvroField attribute. Converters convert between the
            property type and the avro type.
            </summary>
        </member>
        <member name="M:Avro.Reflect.IAvroFieldConverter.ToAvroType(System.Object,Avro.Schema)">
            <summary>
            Convert from the C# type to the avro type
            </summary>
            <param name="o">Value to convert</param>
            <param name="s">Schema</param>
            <returns>Converted value</returns>
        </member>
        <member name="M:Avro.Reflect.IAvroFieldConverter.FromAvroType(System.Object,Avro.Schema)">
            <summary>
            Convert from the avro type to the C# type
            </summary>
            <param name="o">Value to convert</param>
            <param name="s">Schema</param>
            <returns>Converted value</returns>
        </member>
        <member name="M:Avro.Reflect.IAvroFieldConverter.GetAvroType">
            <summary>
            Avro type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.IAvroFieldConverter.GetPropertyType">
            <summary>
            Property type
            </summary>
            <returns></returns>
        </member>
        <member name="T:Avro.Reflect.ReflectDefaultReader">
            <summary>
            Reader class for reading data and storing into specific classes
            </summary>
        </member>
        <member name="P:Avro.Reflect.ReflectDefaultReader.MapType">
            <summary>
            C# type to create when deserializing a map. Must implement IDictionary&lt;,&gt; and the first
            type parameter must be a string. Default is System.Collections.Generic.Dictionary
            </summary>
        </member>
        <member name="P:Avro.Reflect.ReflectDefaultReader.ClassCache">
            <summary>
            Class cache
            </summary>
        </member>
        <member name="P:Avro.Reflect.ReflectDefaultReader.RecordFactory">
            <summary>
            Delegate to a factory method to create objects of type x. If you are deserializing to interfaces
            you could use an IoC container factory insread of the default. Default is Activator.CreateInstance()
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.ReflectDefaultReader.#ctor(System.Type,Avro.Schema,Avro.Schema,Avro.Reflect.ClassCache)">
            <summary>
            Constructor
            </summary>
            <param name="objType"></param>
            <param name="writerSchema"></param>
            <param name="readerSchema"></param>
            <param name="cache"></param>
        </member>
        <member name="M:Avro.Reflect.ReflectDefaultReader.GetTypeFromSchema(Avro.Schema,System.Boolean)">
            <summary>
            Gets the string representation of the schema's data type
            </summary>
            <param name="schema">schema</param>
            <param name="nullable">flag to indicate union with null</param>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.ReflectDefaultReader.GetDefaultValue(Avro.Schema,Newtonsoft.Json.Linq.JToken)">
            <summary>
            Gets the default value for a schema object
            </summary>
            <param name="s"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.ReflectDefaultReader.ReadEnum(System.Object,Avro.EnumSchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Deserializes a enum. Uses CreateEnum to construct the new enum object.
            </summary>
            <param name="reuse">If appropirate, uses this instead of creating a new enum object.</param>
            <param name="writerSchema">The schema the writer used while writing the enum</param>
            <param name="readerSchema">The schema the reader is using</param>
            <param name="d">The decoder for deserialization.</param>
            <returns>An enum object.</returns>
        </member>
        <member name="M:Avro.Reflect.ReflectDefaultReader.ReadRecord(System.Object,Avro.RecordSchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Deserializes a record from the stream.
            </summary>
            <param name="reuse">If not null, a record object that could be reused for returning the result</param>
            <param name="writerSchema">The writer's RecordSchema</param>
            <param name="readerSchema">The reader's schema, must be RecordSchema too.</param>
            <param name="dec">The decoder for deserialization</param>
            <returns>The record object just read</returns>
        </member>
        <member name="M:Avro.Reflect.ReflectDefaultReader.ReadFixed(System.Object,Avro.FixedSchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Deserializes a fixed object and returns the object. The default implementation uses CreateFixed()
            and GetFixedBuffer() and returns what CreateFixed() returned.
            </summary>
            <param name="reuse">If appropriate, uses this object instead of creating a new one.</param>
            <param name="writerSchema">The FixedSchema the writer used during serialization.</param>
            <param name="readerSchema">The schema that the readr uses. Must be a FixedSchema with the same
            size as the writerSchema.</param>
            <param name="d">The decoder for deserialization.</param>
            <returns>The deserilized object.</returns>
        </member>
        <member name="M:Avro.Reflect.ReflectDefaultReader.ReadArray(System.Object,Avro.ArraySchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Reads an array from the given decoder
            </summary>
            <param name="reuse">object to store data read</param>
            <param name="writerSchema">schema of the object that wrote the data</param>
            <param name="readerSchema">schema of the object that will store the data</param>
            <param name="dec">decoder object that contains the data to be read</param>
            <returns>array</returns>
        </member>
        <member name="M:Avro.Reflect.ReflectDefaultReader.ReadMap(System.Object,Avro.MapSchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Deserialized an avro map.
            </summary>
            <param name="reuse">If appropriate, use this instead of creating a new map object.</param>
            <param name="writerSchema">The schema the writer used to write the map.</param>
            <param name="readerSchema">The schema the reader is using.</param>
            <param name="d">The decoder for serialization.</param>
            <returns>The deserialized map object.</returns>
        </member>
        <member name="T:Avro.Reflect.ReflectDefaultWriter">
            <summary>
            Class for writing data from any specific objects
            </summary>
        </member>
        <member name="P:Avro.Reflect.ReflectDefaultWriter.ClassCache">
            <summary>
            Class cache
            </summary>
        </member>
        <member name="M:Avro.Reflect.ReflectDefaultWriter.#ctor(System.Type,Avro.Schema,Avro.Reflect.ClassCache)">
            <summary>
            Constructor
            </summary>
            <param name="objType"></param>
            <param name="schema"></param>
            <param name="cache"></param>
        </member>
        <member name="M:Avro.Reflect.ReflectDefaultWriter.#ctor(Avro.Schema)">
            <summary>
            Constructor
            </summary>
            <param name="schema"></param>
        </member>
        <member name="M:Avro.Reflect.ReflectDefaultWriter.WriteRecord(Avro.RecordSchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Serialized a record using the given RecordSchema. It uses GetField method
            to extract the field value from the given object.
            </summary>
            <param name="schema">The RecordSchema to use for serialization</param>
            <param name="value">The value to be serialized</param>
            <param name="encoder">The Encoder for serialization</param>
        </member>
        <member name="M:Avro.Reflect.ReflectDefaultWriter.WriteFixed(Avro.FixedSchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Validates that the record is a fixed record object and that the schema in the object is the
            same as the given writer schema. Writes the given fixed record into the given encoder
            </summary>
            <param name="schema">writer schema</param>
            <param name="value">fixed object to write</param>
            <param name="encoder">encoder to write to</param>
        </member>
        <member name="M:Avro.Reflect.ReflectDefaultWriter.WriteArray(Avro.ArraySchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Serialized an array. The default implementation calls EnsureArrayObject() to ascertain that the
            given value is an array. It then calls GetArrayLength() and GetArrayElement()
            to access the members of the array and then serialize them.
            </summary>
            <param name="schema">The ArraySchema for serialization</param>
            <param name="value">The value being serialized</param>
            <param name="encoder">The encoder for serialization</param>
        </member>
        <member name="M:Avro.Reflect.ReflectDefaultWriter.WriteMap(Avro.MapSchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Writes the given map into the given encoder.
            </summary>
            <param name="schema">writer schema</param>
            <param name="value">map to write</param>
            <param name="encoder">encoder to write to</param>
        </member>
        <member name="M:Avro.Reflect.ReflectDefaultWriter.Matches(Avro.Schema,System.Object)">
            <summary>
            Determines whether an object matches a schema. In the case of enums and records the code looks up the
            Enum and class caches respectively. Used when writing unions.
            </summary>
            <param name="sc"></param>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Avro.Reflect.ReflectReader`1">
            <summary>
            Reader wrapper class for reading data and storing into specific classes
            </summary>
            <typeparam name="T">Specific class type</typeparam>
        </member>
        <member name="F:Avro.Reflect.ReflectReader`1._reader">
            <summary>
            Reader class for reading data and storing into specific classes
            </summary>
        </member>
        <member name="P:Avro.Reflect.ReflectReader`1.Reader">
            <summary>
            Default reader
            </summary>
        </member>
        <member name="P:Avro.Reflect.ReflectReader`1.WriterSchema">
            <summary>
            Schema for the writer class
            </summary>
        </member>
        <member name="P:Avro.Reflect.ReflectReader`1.ReaderSchema">
            <summary>
            Schema for the reader class
            </summary>
        </member>
        <member name="M:Avro.Reflect.ReflectReader`1.#ctor(Avro.Schema,Avro.Schema,Avro.Reflect.ClassCache)">
            <summary>
            Constructs a generic reader for the given schemas using the DefaultReader. If the
            reader's and writer's schemas are different this class performs the resolution.
            </summary>
            <param name="writerSchema">The schema used while generating the data</param>
            <param name="readerSchema">The schema desired by the reader</param>
            <param name="cache">Class cache</param>
        </member>
        <member name="M:Avro.Reflect.ReflectReader`1.#ctor(Avro.Reflect.ReflectDefaultReader)">
            <summary>
            Constructs a generic reader from an instance of a ReflectDefaultReader (non-generic)
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:Avro.Reflect.ReflectReader`1.Read(`0,Avro.IO.Decoder)">
            <summary>
            Generic read function
            </summary>
            <param name="reuse">object to store data read</param>
            <param name="dec">decorder to use for reading data</param>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.ReflectReader`1.Read(Avro.IO.Decoder)">
            <summary>
            Generic read function
            </summary>
            <param name="dec">decorder to use for reading data</param>
            <returns></returns>
        </member>
        <member name="T:Avro.Reflect.ReflectWriter`1">
            <summary>
            Generic wrapper class for writing data from specific objects
            </summary>
            <typeparam name="T">type name of specific object</typeparam>
        </member>
        <member name="P:Avro.Reflect.ReflectWriter`1.Writer">
            <summary>
            Default writer
            </summary>
        </member>
        <member name="M:Avro.Reflect.ReflectWriter`1.#ctor(Avro.Schema,Avro.Reflect.ClassCache)">
            <summary>
            Constructor
            </summary>
            <param name="schema"></param>
            <param name="cache"></param>
        </member>
        <member name="P:Avro.Reflect.ReflectWriter`1.Schema">
            <summary>
            The schema
            </summary>
        </member>
        <member name="M:Avro.Reflect.ReflectWriter`1.#ctor(Avro.Reflect.ReflectDefaultWriter)">
            <summary>
            Constructor with already created default writer.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:Avro.Reflect.ReflectWriter`1.Write(`0,Avro.IO.Encoder)">
            <summary>
            Serializes the given object using this writer's schema.
            </summary>
            <param name="value">The value to be serialized</param>
            <param name="encoder">The encoder to use for serializing</param>
        </member>
        <member name="T:Avro.Reflect.TypedFieldConverter`2">
            <summary>
            Constructor
            </summary>
            <typeparam name="TAvro">Avro type</typeparam>
            <typeparam name="TProperty">Property type</typeparam>
        </member>
        <member name="M:Avro.Reflect.TypedFieldConverter`2.From(`0,Avro.Schema)">
            <summary>
            Convert from Avro type to property type
            </summary>
            <param name="o">Avro value</param>
            <param name="s">Schema</param>
            <returns>Property value</returns>
        </member>
        <member name="M:Avro.Reflect.TypedFieldConverter`2.To(`1,Avro.Schema)">
            <summary>
            Convert from property type to Avro type
            </summary>
            <param name="o"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.TypedFieldConverter`2.FromAvroType(System.Object,Avro.Schema)">
            <summary>
            Implement untyped interface
            </summary>
            <param name="o"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.TypedFieldConverter`2.GetAvroType">
            <summary>
            Implement untyped interface
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.TypedFieldConverter`2.GetPropertyType">
            <summary>
            Implement untyped interface
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.Reflect.TypedFieldConverter`2.ToAvroType(System.Object,Avro.Schema)">
            <summary>
            Implement untyped interface
            </summary>
            <param name="o"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:Avro.ArraySchema">
            <summary>
            Class for array type schemas
            </summary>
        </member>
        <member name="P:Avro.ArraySchema.ItemSchema">
            <summary>
            Schema for the array 'type' attribute
            </summary>
        </member>
        <member name="M:Avro.ArraySchema.NewInstance(Newtonsoft.Json.Linq.JToken,Avro.PropertyMap,Avro.SchemaNames,System.String)">
            <summary>
            Static class to return a new instance of ArraySchema
            </summary>
            <param name="jtok">JSON object for the array schema</param>
            <param name="props">dictionary that provides access to custom properties</param>
            <param name="names">list of named schemas already parsed</param>
            <param name="encspace">enclosing namespace for the array schema</param>
            <returns></returns>
        </member>
        <member name="M:Avro.ArraySchema.#ctor(Avro.Schema,Avro.PropertyMap)">
            <summary>
            Constructor
            </summary>
            <param name="items">schema for the array items type</param>
            <param name="props">dictionary that provides access to custom properties</param>
        </member>
        <member name="M:Avro.ArraySchema.WriteJsonFields(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames,System.String)">
            <summary>
            Writes the array schema in JSON format
            </summary>
            <param name="writer">JSON writer</param>
            <param name="names">list of named schemas already written</param>
            <param name="encspace">enclosing namespace</param>
        </member>
        <member name="M:Avro.ArraySchema.CanRead(Avro.Schema)">
            <summary>
            Checks if this schema can read data written by the given schema. Used for decoding data.
            </summary>
            <param name="writerSchema">writer schema</param>
            <returns>true if this and writer schema are compatible based on the AVRO specification, false otherwise</returns>
        </member>
        <member name="M:Avro.ArraySchema.Equals(System.Object)">
            <summary>
            Function to compare equality of two array schemas
            </summary>
            <param name="obj">other array schema</param>
            <returns>true two schemas are equal, false otherwise</returns>
        </member>
        <member name="M:Avro.ArraySchema.GetHashCode">
            <summary>
            Hashcode function
            </summary>
            <returns></returns>
        </member>
        <member name="T:Avro.AvroException">
            <summary>
            A generic Avro exception.
            </summary>
        </member>
        <member name="M:Avro.AvroException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroException"/> class.
            </summary>
        </member>
        <member name="M:Avro.AvroException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroException"/> class.
            </summary>
            <param name="s">The message that describes the error.</param>
        </member>
        <member name="M:Avro.AvroException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroException"/> class.
            </summary>
            <param name="s">The message that describes the error.</param>
            <param name="inner">
            The exception that is the cause of the current exception, or a null reference
            if no inner exception is specified.
            </param>
        </member>
        <member name="T:Avro.AvroTypeException">
            <summary>
            Used to communicate an exception associated with Avro typing.
            </summary>
        </member>
        <member name="M:Avro.AvroTypeException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroTypeException"/> class.
            </summary>
        </member>
        <member name="M:Avro.AvroTypeException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroTypeException"/> class.
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:Avro.AvroTypeException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.AvroTypeException"/> class.
            </summary>
            <param name="message">
            The error message that explains the reason for the exception.
            </param>
            <param name="innerException">
            The exception that is the cause of the current exception, or a null reference if no
            inner exception is specified.
            </param>
        </member>
        <member name="T:Avro.EnumSchema">
            <summary>
            Class for enum type schemas
            </summary>
        </member>
        <member name="P:Avro.EnumSchema.Symbols">
            <summary>
            List of strings representing the enum symbols
            </summary>
        </member>
        <member name="P:Avro.EnumSchema.Default">
            <summary>
            The default token to use when deserializing an enum when the provided token is not found
            </summary>
        </member>
        <member name="F:Avro.EnumSchema.symbolMap">
            <summary>
            Map of enum symbols and it's corresponding ordinal number
            </summary>
        </member>
        <member name="P:Avro.EnumSchema.Count">
            <summary>
            Count of enum symbols
            </summary>
        </member>
        <member name="M:Avro.EnumSchema.NewInstance(Newtonsoft.Json.Linq.JToken,Avro.PropertyMap,Avro.SchemaNames,System.String)">
            <summary>
            Static function to return new instance of EnumSchema
            </summary>
            <param name="jtok">JSON object for enum schema</param>
            <param name="props">dictionary that provides access to custom properties</param>
            <param name="names">list of named schema already parsed in</param>
            <param name="encspace">enclosing namespace for the enum schema</param>
            <returns>new instance of enum schema</returns>
        </member>
        <member name="M:Avro.EnumSchema.#ctor(Avro.SchemaName,System.Collections.Generic.IList{Avro.SchemaName},System.Collections.Generic.List{System.String},System.Collections.Generic.IDictionary{System.String,System.Int32},Avro.PropertyMap,Avro.SchemaNames,System.String,System.String)">
            <summary>
            Constructor for enum schema
            </summary>
            <param name="name">name of enum</param>
            <param name="aliases">list of aliases for the name</param>
            <param name="symbols">list of enum symbols</param>
            <param name="symbolMap">map of enum symbols and value</param>
            <param name="props">custom properties on this schema</param>
            <param name="names">list of named schema already read</param>
            <param name="doc">documentation for this named schema</param>
            <param name="defaultSymbol">default symbol</param>
        </member>
        <member name="M:Avro.EnumSchema.WriteJsonFields(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames,System.String)">
            <summary>
            Writes enum schema in JSON format
            </summary>
            <param name="writer">JSON writer</param>
            <param name="names">list of named schema already written</param>
            <param name="encspace">enclosing namespace of the enum schema</param>
        </member>
        <member name="M:Avro.EnumSchema.Ordinal(System.String)">
            <summary>
            Returns the position of the given symbol within this enum.
            Throws AvroException if the symbol is not found in this enum.
            </summary>
            <param name="symbol">name of the symbol to find</param>
            <returns>position of the given symbol in this enum schema</returns>
        </member>
        <member name="P:Avro.EnumSchema.Item(System.Int32)">
            <summary>
            Returns the enum symbol of the given index to the list
            </summary>
            <param name="index">symbol index</param>
            <returns>symbol name</returns>
        </member>
        <member name="M:Avro.EnumSchema.Contains(System.String)">
            <summary>
            Checks if given symbol is in the list of enum symbols
            </summary>
            <param name="symbol">symbol to check</param>
            <returns>true if symbol exist, false otherwise</returns>
        </member>
        <member name="M:Avro.EnumSchema.GetEnumerator">
            <summary>
            Returns an enumerator that enumerates the symbols in this enum schema in the order of their definition.
            </summary>
            <returns>Enumeration over the symbols of this enum schema</returns>
        </member>
        <member name="M:Avro.EnumSchema.Equals(System.Object)">
            <summary>
            Checks equality of two enum schema
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Avro.EnumSchema.GetHashCode">
            <summary>
            Hashcode function
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.EnumSchema.CanRead(Avro.Schema)">
            <summary>
            Checks if this schema can read data written by the given schema. Used for decoding data.
            </summary>
            <param name="writerSchema">writer schema</param>
            <returns>true if this and writer schema are compatible based on the AVRO specification, false otherwise</returns>
        </member>
        <member name="T:Avro.Field">
            <summary>
            Class for fields defined in a record
            </summary>
        </member>
        <member name="T:Avro.Field.SortOrder">
            <summary>
            Enum for the sorting order of record fields
            </summary>
        </member>
        <member name="F:Avro.Field.SortOrder.ascending">
            <summary>
            Ascending order.
            </summary>
        </member>
        <member name="F:Avro.Field.SortOrder.descending">
            <summary>
            Descending order.
            </summary>
        </member>
        <member name="F:Avro.Field.SortOrder.ignore">
            <summary>
            Ignore sort order.
            </summary>
        </member>
        <member name="F:Avro.Field.Name">
            <summary>
            Name of the field.
            </summary>
        </member>
        <member name="F:Avro.Field.aliases">
            <summary>
            List of aliases for the field name
            </summary>
        </member>
        <member name="P:Avro.Field.Aliases">
            <summary>
            List of aliases for the field name.
            </summary>
        </member>
        <member name="P:Avro.Field.Pos">
            <summary>
            Position of the field within its record.
            </summary>
        </member>
        <member name="P:Avro.Field.Documentation">
            <summary>
            Documentation for the field, if any. Null if there is no documentation.
            </summary>
        </member>
        <member name="P:Avro.Field.DefaultValue">
            <summary>
            The default value for the field stored as JSON object, if defined. Otherwise, null.
            </summary>
        </member>
        <member name="P:Avro.Field.Ordering">
            <summary>
            Order of the field
            </summary>
        </member>
        <member name="P:Avro.Field.Schema">
            <summary>
            Field type's schema
            </summary>
        </member>
        <member name="F:Avro.Field.Props">
            <summary>
            Custom properties for the field. We don't store the fields custom properties in
            the field type's schema because if the field type is only a reference to the schema
            instead of an actual schema definition, then the schema could already have it's own set
            of custom properties when it was previously defined.
            </summary>
        </member>
        <member name="F:Avro.Field.JtokenEqual">
            <summary>
            Static comparer object for JSON objects such as the fields default value
            </summary>
        </member>
        <member name="M:Avro.Field.#ctor(Avro.Schema,System.String,System.Collections.Generic.IList{System.String},System.Int32,System.String,Newtonsoft.Json.Linq.JToken,Avro.Field.SortOrder,Avro.PropertyMap)">
            <summary>
            A flag to indicate if reader schema has a field that is missing from writer schema and has a default value
            This is set in CanRead() which is always be called before deserializing data
            </summary>
            <summary>
            Constructor for the field class
            </summary>
            <param name="schema">schema for the field type</param>
            <param name="name">name of the field</param>
            <param name="aliases">list of aliases for the name of the field</param>
            <param name="pos">position of the field</param>
            <param name="doc">documentation for the field</param>
            <param name="defaultValue">field's default value if it exists</param>
            <param name="sortorder">sort order of the field</param>
            <param name="props">dictionary that provides access to custom properties</param>
        </member>
        <member name="M:Avro.Field.writeJson(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames,System.String)">
            <summary>
            Writes the Field class in JSON format
            </summary>
            <param name="writer">JSON writer</param>
            <param name="names">list of named schemas already written</param>
            <param name="encspace">enclosing namespace for the field</param>
        </member>
        <member name="M:Avro.Field.GetAliases(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Parses the 'aliases' property from the given JSON token
            </summary>
            <param name="jtok">JSON object to read</param>
            <returns>List of string that represents the list of alias. If no 'aliases' specified, then it returns null.</returns>
        </member>
        <member name="M:Avro.Field.GetProperty(System.String)">
            <summary>
            Returns the field's custom property value given the property name
            </summary>
            <param name="key">custom property name</param>
            <returns>custom property value</returns>
        </member>
        <member name="M:Avro.Field.Equals(System.Object)">
            <summary>
            Compares two field objects
            </summary>
            <param name="obj">field to compare with this field</param>
            <returns>true if two fields are equal, false otherwise</returns>
        </member>
        <member name="M:Avro.Field.areEqual(System.Object,System.Object)">
            <summary>
            Compares two objects
            </summary>
            <param name="o1">first object</param>
            <param name="o2">second object</param>
            <returns>true if two objects are equal, false otherwise</returns>
        </member>
        <member name="M:Avro.Field.GetHashCode">
            <summary>
            Hash code function
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.Field.getHashCode(System.Object)">
            <summary>
            Hash code helper function
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Avro.FixedSchema">
            <summary>
            Class for fixed schemas
            </summary>
        </member>
        <member name="P:Avro.FixedSchema.Size">
            <summary>
            Fixed size for the bytes
            </summary>
        </member>
        <member name="M:Avro.FixedSchema.NewInstance(Newtonsoft.Json.Linq.JToken,Avro.PropertyMap,Avro.SchemaNames,System.String)">
            <summary>
            Static function to return new instance of the fixed schema class
            </summary>
            <param name="jtok">JSON object for the fixed schema</param>
            <param name="props">dictionary that provides access to custom properties</param>
            <param name="names">list of named schema already parsed in</param>
            <param name="encspace">enclosing namespace of the fixed schema</param>
            <returns></returns>
        </member>
        <member name="M:Avro.FixedSchema.#ctor(Avro.SchemaName,System.Collections.Generic.IList{Avro.SchemaName},System.Int32,Avro.PropertyMap,Avro.SchemaNames,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">name of the fixed schema</param>
            <param name="aliases">list of aliases for the name</param>
            <param name="size">fixed size</param>
            <param name="props">custom properties on this schema</param>
            <param name="names">list of named schema already parsed in</param>
            <param name="doc">documentation for this named schema</param>
        </member>
        <member name="M:Avro.FixedSchema.WriteJsonFields(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames,System.String)">
            <summary>
            Writes the fixed schema class in JSON format
            </summary>
            <param name="writer">JSON writer</param>
            <param name="names">list of named schema already written</param>
            <param name="encspace">enclosing namespace for the fixed schema</param>
        </member>
        <member name="M:Avro.FixedSchema.Equals(System.Object)">
            <summary>
            Compares two fixed schemas
            </summary>
            <param name="obj">fixed schema to compare against this schema</param>
            <returns>true if two schemas are the same, false otherwise</returns>
        </member>
        <member name="M:Avro.FixedSchema.GetHashCode">
            <summary>
            Hash code function
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.FixedSchema.CanRead(Avro.Schema)">
            <summary>
            Checks if this schema can read data written by the given schema. Used for decoding data.
            </summary>
            <param name="writerSchema">writer schema</param>
            <returns>true if this and writer schema are compatible based on the AVRO specification, false otherwise</returns>
        </member>
        <member name="M:Avro.JsonHelper.GetOptionalString(Newtonsoft.Json.Linq.JToken,System.String)">
            <summary>
            Retrieves the optional string property value for the given property name from the given JSON object.
            This throws an exception if property exists but it is not a string.
            </summary>
            <param name="jtok">JSON object to read</param>
            <param name="field">property name</param>
            <returns>property value if property exists, null if property doesn't exist in the JSON object</returns>
        </member>
        <member name="M:Avro.JsonHelper.GetRequiredString(Newtonsoft.Json.Linq.JToken,System.String)">
            <summary>
            Retrieves the required string property value for the given property name from the given JSON object.
            </summary>
            <param name="jtok">JSON object to read</param>
            <param name="field">property name</param>
            <returns>property value</returns>
        </member>
        <member name="M:Avro.JsonHelper.GetRequiredInteger(Newtonsoft.Json.Linq.JToken,System.String)">
            <summary>
            Retrieves the required int property value for the given property name from the given JSON object.
            </summary>
            <param name="jtok">JSON object to read</param>
            <param name="field">property name</param>
            <returns>property value</returns>
        </member>
        <member name="M:Avro.JsonHelper.GetOptionalBoolean(Newtonsoft.Json.Linq.JToken,System.String)">
            <summary>
            Retrieves the optional boolean property value for the given property name from the given JSON object.
            </summary>
            <param name="jtok">JSON object to read</param>
            <param name="field">property name</param>
            <returns>null if property doesn't exist, otherise returns property boolean value</returns>
        </member>
        <member name="M:Avro.JsonHelper.writeIfNotNullOrEmpty(Newtonsoft.Json.JsonTextWriter,System.String,System.String)">
            <summary>
            Writes JSON property name and value if value is not null or empty
            </summary>
            <param name="writer">JSON writer</param>
            <param name="key">property name</param>
            <param name="value">property value</param>
        </member>
        <member name="M:Avro.JsonHelper.writeIfNotNull(Newtonsoft.Json.JsonTextWriter,System.String,System.String)">
            <summary>
            Write JSON property name and value, if value is not null
            </summary>
            <param name="writer">JSON writer</param>
            <param name="key">property name</param>
            <param name="value">property value</param>
        </member>
        <member name="T:Avro.LogicalSchema">
            <summary>
            Class for logical type schemas.
            </summary>
        </member>
        <member name="P:Avro.LogicalSchema.BaseSchema">
            <summary>
            Schema for the underlying type that the logical type is based on.
            </summary>
        </member>
        <member name="P:Avro.LogicalSchema.LogicalTypeName">
            <summary>
            The logical type name.
            </summary>
        </member>
        <member name="P:Avro.LogicalSchema.LogicalType">
            <summary>
            The logical type implementation that supports this logical type.
            </summary>
        </member>
        <member name="M:Avro.LogicalSchema.WriteJson(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames,System.String)">
            <summary>
            Writes logical schema in JSON format
            </summary>
            <param name="writer">JSON writer</param>
            <param name="names">list of named schemas already written</param>
            <param name="encspace">enclosing namespace of the schema</param>
        </member>
        <member name="M:Avro.LogicalSchema.CanRead(Avro.Schema)">
            <summary>
            Checks if this schema can read data written by the given schema. Used for decoding data.
            </summary>
            <param name="writerSchema">writer schema</param>
            <returns>true if this and writer schema are compatible based on the AVRO specification, false otherwise</returns>
        </member>
        <member name="M:Avro.LogicalSchema.Equals(System.Object)">
            <summary>
            Function to compare equality of two logical schemas
            </summary>
            <param name="obj">other logical schema</param>
            <returns>true if two schemas are equal, false otherwise</returns>
        </member>
        <member name="M:Avro.LogicalSchema.GetHashCode">
            <summary>
            Hashcode function
            </summary>
            <returns></returns>
        </member>
        <member name="T:Avro.MapSchema">
            <summary>
            Class for map schemas
            </summary>
        </member>
        <member name="P:Avro.MapSchema.ValueSchema">
            <summary>
            Schema for map values type
            </summary>
        </member>
        <member name="M:Avro.MapSchema.CreateMap(Avro.Schema)">
            <summary>
            Creates a new <see cref="T:Avro.MapSchema"/> from the given schema.
            </summary>
            <param name="type">Schema to create the map schema from.</param>
            <returns>A new <see cref="T:Avro.MapSchema"/>.</returns>
        </member>
        <member name="M:Avro.MapSchema.NewInstance(Newtonsoft.Json.Linq.JToken,Avro.PropertyMap,Avro.SchemaNames,System.String)">
            <summary>
            Static function to return new instance of map schema
            </summary>
            <param name="jtok">JSON object for the map schema</param>
            <param name="props">dictionary that provides access to custom properties</param>
            <param name="names">list of named schemas already read</param>
            <param name="encspace">enclosing namespace of the map schema</param>
            <returns></returns>
        </member>
        <member name="M:Avro.MapSchema.#ctor(Avro.Schema,Avro.PropertyMap)">
            <summary>
            Constructor for map schema class
            </summary>
            <param name="valueSchema">schema for map values type</param>
            <param name="props">dictionary that provides access to custom properties</param>
        </member>
        <member name="M:Avro.MapSchema.WriteJsonFields(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames,System.String)">
            <summary>
            Writes map schema in JSON format
            </summary>
            <param name="writer">JSON writer</param>
            <param name="names">list of named schemas already written</param>
            <param name="encspace">enclosing namespace of the map schema</param>
        </member>
        <member name="M:Avro.MapSchema.CanRead(Avro.Schema)">
            <summary>
            Checks if this schema can read data written by the given schema. Used for decoding data.
            </summary>
            <param name="writerSchema">writer schema</param>
            <returns>true if this and writer schema are compatible based on the AVRO specification, false otherwise</returns>
        </member>
        <member name="M:Avro.MapSchema.Equals(System.Object)">
            <summary>
            Compares equality of two map schemas
            </summary>
            <param name="obj">map schema to compare against this schema</param>
            <returns>true if two schemas are equal, false otherwise</returns>
        </member>
        <member name="M:Avro.MapSchema.GetHashCode">
            <summary>
            Hashcode function
            </summary>
            <returns></returns>
        </member>
        <member name="T:Avro.NamedSchema">
            <summary>
            Base class for all named schemas: fixed, enum, record
            </summary>
        </member>
        <member name="P:Avro.NamedSchema.SchemaName">
            <summary>
            Name of the schema, contains name, namespace and enclosing namespace
            </summary>
        </member>
        <member name="P:Avro.NamedSchema.Name">
            <summary>
            Name of the schema
            </summary>
        </member>
        <member name="P:Avro.NamedSchema.Namespace">
            <summary>
            Namespace of the schema
            </summary>
        </member>
        <member name="P:Avro.NamedSchema.Fullname">
            <summary>
            Namespace.Name of the schema
            </summary>
        </member>
        <member name="P:Avro.NamedSchema.Documentation">
            <summary>
            Documentation for the schema, if any. Null if there is no documentation.
            </summary>
        </member>
        <member name="F:Avro.NamedSchema.aliases">
            <summary>
            List of aliases for this named schema
            </summary>
        </member>
        <member name="M:Avro.NamedSchema.NewInstance(Newtonsoft.Json.Linq.JObject,Avro.PropertyMap,Avro.SchemaNames,System.String)">
            <summary>
            Static function to return a new instance of the named schema
            </summary>
            <param name="jo">JSON object of the named schema</param>
            <param name="props">dictionary that provides access to custom properties</param>
            <param name="names">list of named schemas already read</param>
            <param name="encspace">enclosing namespace of the named schema</param>
            <returns></returns>
        </member>
        <member name="M:Avro.NamedSchema.#ctor(Avro.Schema.Type,Avro.SchemaName,System.Collections.Generic.IList{Avro.SchemaName},Avro.PropertyMap,Avro.SchemaNames,System.String)">
            <summary>
            Constructor for named schema class
            </summary>
            <param name="type">schema type</param>
            <param name="name">name</param>
            <param name="aliases">aliases for this named schema</param>
            <param name="props">custom properties on this schema</param>
            <param name="names">list of named schemas already read</param>
            <param name="doc">documentation for this named schema</param>
        </member>
        <member name="M:Avro.NamedSchema.GetName(Newtonsoft.Json.Linq.JToken,System.String)">
            <summary>
            Parses the name and namespace from the given JSON schema object then creates
            SchemaName object including the given enclosing namespace
            </summary>
            <param name="jtok">JSON object to read</param>
            <param name="encspace">enclosing namespace</param>
            <returns>new SchemaName object</returns>
        </member>
        <member name="M:Avro.NamedSchema.GetAliases(Newtonsoft.Json.Linq.JToken,System.String,System.String)">
            <summary>
            Parses the 'aliases' property from the given JSON token
            </summary>
            <param name="jtok">JSON object to read</param>
            <param name="space">namespace of the name this alias is for</param>
            <param name="encspace">enclosing namespace of the name this alias is for</param>        
            <returns>List of SchemaName that represents the list of alias. If no 'aliases' specified, then it returns null.</returns>
        </member>
        <member name="M:Avro.NamedSchema.InAliases(Avro.SchemaName)">
            <summary>
            Determines whether the given schema name is one of this <see cref="T:Avro.NamedSchema"/>'s
            aliases.
            </summary>
            <param name="name">Schema name to test.</param>
            <returns>
            True if <paramref name="name"/> is one of this schema's aliases; false otherwise.
            </returns>
        </member>
        <member name="M:Avro.NamedSchema.WriteJson(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames,System.String)">
            <summary>
            Writes named schema in JSON format
            </summary>
            <param name="writer">JSON writer</param>
            <param name="names">list of named schemas already written</param>
            <param name="encspace">enclosing namespace of the named schema</param>
        </member>
        <member name="M:Avro.NamedSchema.WriteJsonFields(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames,System.String)">
            <summary>
            Writes named schema in JSON format
            </summary>
            <param name="writer">JSON writer</param>
            <param name="names">list of named schemas already written</param>
            <param name="encspace">enclosing namespace of the named schema</param>
        </member>
        <member name="T:Avro.PrimitiveSchema">
            <summary>
            Class for schemas of primitive types
            </summary>
        </member>
        <member name="M:Avro.PrimitiveSchema.#ctor(Avro.Schema.Type,Avro.PropertyMap)">
            <summary>
            Constructor for primitive schema
            </summary>
            <param name="type"></param>
            <param name="props">dictionary that provides access to custom properties</param>
        </member>
        <member name="M:Avro.PrimitiveSchema.NewInstance(System.String,Avro.PropertyMap)">
            <summary>
            Static function to return new instance of primitive schema
            </summary>
            <param name="type">primitive type</param>
            <param name="props">dictionary that provides access to custom properties</param>
            <returns></returns>
        </member>
        <member name="M:Avro.PrimitiveSchema.WriteJson(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames,System.String)">
            <summary>
            Writes primitive schema in JSON format
            </summary>
            <param name="w"></param>
            <param name="names"></param>
            <param name="encspace"></param>
        </member>
        <member name="M:Avro.PrimitiveSchema.CanRead(Avro.Schema)">
            <summary>
            Checks if this schema can read data written by the given schema. Used for decoding data.
            </summary>
            <param name="writerSchema">writer schema</param>
            <returns>true if this and writer schema are compatible based on the AVRO specification, false otherwise</returns>
        </member>
        <member name="M:Avro.PrimitiveSchema.Equals(System.Object)">
            <summary>
            Function to compare equality of two primitive schemas
            </summary>
            <param name="obj">other primitive schema</param>
            <returns>true two schemas are equal, false otherwise</returns>
        </member>
        <member name="M:Avro.PrimitiveSchema.GetHashCode">
            <summary>
            Hashcode function
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.PrimitiveSchema.ToString">
            <summary>
            Returns the canonical JSON representation of this schema.
            </summary>
            <returns>The canonical JSON representation of this schema.</returns>
        </member>
        <member name="T:Avro.PropertyMap">
            <summary>
            Provides access to custom properties (those not defined in the Avro spec) in a JSON object.
            </summary>
        </member>
        <member name="F:Avro.PropertyMap.ReservedProps">
            <summary>
            Set of reserved schema property names, any other properties not defined in this set are custom properties and can be added to this map
            </summary>
        </member>
        <member name="M:Avro.PropertyMap.Parse(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Parses the custom properties from the given JSON object and stores them
            into the schema's list of custom properties
            </summary>
            <param name="jtok">JSON object to prase</param>
        </member>
        <member name="M:Avro.PropertyMap.Set(System.String,System.String)">
            <summary>
            Adds a custom property to the schema
            </summary>
            <param name="key">custom property name</param>
            <param name="value">custom property value</param>
        </member>
        <member name="M:Avro.PropertyMap.WriteJson(Newtonsoft.Json.JsonTextWriter)">
            <summary>
            Writes the schema's custom properties in JSON format
            </summary>
            <param name="writer">JSON writer</param>
        </member>
        <member name="M:Avro.PropertyMap.Equals(System.Object)">
            <summary>
            Function to compare equality of two PropertyMaps
            </summary>
            <param name="obj">other PropertyMap</param>
            <returns>true if contents of the two maps are the same, false otherwise</returns>
        </member>
        <member name="M:Avro.PropertyMap.GetHashCode">
            <summary>
            Hashcode function
            </summary>
            <returns></returns>
        </member>
        <member name="T:Avro.RecordSchema">
            <summary>
            Class for record schemas
            </summary>
        </member>
        <member name="P:Avro.RecordSchema.Fields">
            <summary>
            List of fields in the record
            </summary>
        </member>
        <member name="P:Avro.RecordSchema.Count">
            <summary>
            Number of fields in the record
            </summary>
        </member>
        <member name="F:Avro.RecordSchema.fieldLookup">
            <summary>
            Map of field name and Field object for faster field lookups
            </summary>
        </member>
        <member name="M:Avro.RecordSchema.NewInstance(Avro.Schema.Type,Newtonsoft.Json.Linq.JToken,Avro.PropertyMap,Avro.SchemaNames,System.String)">
            <summary>
            Static function to return new instance of the record schema
            </summary>
            <param name="type">type of record schema, either record or error</param>
            <param name="jtok">JSON object for the record schema</param>
            <param name="props">dictionary that provides access to custom properties</param>
            <param name="names">list of named schema already read</param>
            <param name="encspace">enclosing namespace of the records schema</param>
            <returns>new RecordSchema object</returns>
        </member>
        <member name="M:Avro.RecordSchema.#ctor(Avro.Schema.Type,Avro.SchemaName,System.Collections.Generic.IList{Avro.SchemaName},Avro.PropertyMap,System.Collections.Generic.List{Avro.Field},System.Boolean,System.Collections.Generic.IDictionary{System.String,Avro.Field},System.Collections.Generic.IDictionary{System.String,Avro.Field},Avro.SchemaNames,System.String)">
            <summary>
            Constructor for the record schema
            </summary>
            <param name="type">type of record schema, either record or error</param>
            <param name="name">name of the record schema</param>
            <param name="aliases">list of aliases for the record name</param>
            <param name="props">custom properties on this schema</param>
            <param name="fields">list of fields for the record</param>
            <param name="request">true if this is an anonymous record with 'request' instead of 'fields'</param>
            <param name="fieldMap">map of field names and field objects</param>
            <param name="fieldAliasMap">map of field aliases and field objects</param>
            <param name="names">list of named schema already read</param>
            <param name="doc">documentation for this named schema</param>
        </member>
        <member name="M:Avro.RecordSchema.createField(Newtonsoft.Json.Linq.JToken,System.Int32,Avro.SchemaNames,System.String)">
            <summary>
            Creates a new field for the record
            </summary>
            <param name="jfield">JSON object for the field</param>
            <param name="pos">position number of the field</param>
            <param name="names">list of named schemas already read</param>
            <param name="encspace">enclosing namespace of the records schema</param>
            <returns>new Field object</returns>
        </member>
        <member name="P:Avro.RecordSchema.Item(System.String)">
            <summary>
            Returns the field with the given name.
            </summary>
            <param name="name">field name</param>
            <returns>Field object</returns>
        </member>
        <member name="M:Avro.RecordSchema.Contains(System.String)">
            <summary>
            Returns true if and only if the record contains a field by the given name.
            </summary>
            <param name="fieldName">The name of the field</param>
            <returns>true if the field exists, false otherwise</returns>
        </member>
        <member name="M:Avro.RecordSchema.TryGetField(System.String,Avro.Field@)">
            <summary>
            Gets a field with a specified name.
            </summary>
            <param name="fieldName">Name of the field to get.</param>
            <param name="field">
            When this method returns true, contains the field with the specified name. When this
            method returns false, null.
            </param>
            <returns>True if a field with the specified name exists; false otherwise.</returns>
        </member>
        <member name="M:Avro.RecordSchema.TryGetFieldAlias(System.String,Avro.Field@)">
            <summary>
            Gets a field with a specified alias.
            </summary>
            <param name="fieldName">Alias of the field to get.</param>
            <param name="field">
            When this method returns true, contains the field with the specified alias. When this
            method returns false, null.
            </param>
            <returns>True if a field with the specified alias exists; false otherwise.</returns>
        </member>
        <member name="M:Avro.RecordSchema.GetEnumerator">
            <summary>
            Returns an enumerator which enumerates over the fields of this record schema
            </summary>
            <returns>Enumerator over the field in the order of their definition</returns>
        </member>
        <member name="M:Avro.RecordSchema.WriteJsonFields(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames,System.String)">
            <summary>
            Writes the records schema in JSON format
            </summary>
            <param name="writer">JSON writer</param>
            <param name="names">list of named schemas already written</param>
            <param name="encspace">enclosing namespace of the record schema</param>
        </member>
        <member name="M:Avro.RecordSchema.Equals(System.Object)">
            <summary>
            Compares equality of two record schemas
            </summary>
            <param name="obj">record schema to compare against this schema</param>
            <returns>true if the two schemas are equal, false otherwise</returns>
        </member>
        <member name="M:Avro.RecordSchema.GetHashCode">
            <summary>
            Hash code function
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.RecordSchema.CanRead(Avro.Schema)">
            <summary>
            Checks if this schema can read data written by the given schema. Used for decoding data.
            </summary>
            <param name="writerSchema">writer schema</param>
            <returns>true if this and writer schema are compatible based on the AVRO specification, false otherwise</returns>
        </member>
        <member name="M:Avro.RecordSchema.protect``1(Avro.Function{``0},Avro.Function{``0},Avro.RecordSchema)">
             We want to protect against infinite recursion when the schema is recursive. We look into a thread local
             to see if we have been into this if so, we execute the bypass function otherwise we execute the main function.
             Before executing the main function, we ensure that we create a marker so that if we come back here recursively
             we can detect it.
            
             The infinite loop happens in ToString(), Equals() and GetHashCode() methods.
             Though it does not happen for CanRead() because of the current implemenation of UnionSchema's can read,
             it could potenitally happen.
             We do a linear seach for the marker as we don't expect the list to be very long.
        </member>
        <member name="T:Avro.Schema">
            <summary>
            Base class for all schema types
            </summary>
        </member>
        <member name="T:Avro.Schema.Type">
            <summary>
            Enum for schema types
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.Null">
            <summary>
            No value.
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.Boolean">
            <summary>
            A binary value.
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.Int">
            <summary>
            A 32-bit signed integer.
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.Long">
            <summary>
            A 64-bit signed integer.
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.Float">
            <summary>
            A single precision (32-bit) IEEE 754 floating-point number.
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.Double">
            <summary>
            A double precision (64-bit) IEEE 754 floating-point number.
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.Bytes">
            <summary>
            A sequence of 8-bit unsigned bytes.
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.String">
            <summary>
            An unicode character sequence.
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.Record">
            <summary>
            A logical collection of fields.
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.Enumeration">
            <summary>
            An enumeration.
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.Array">
            <summary>
            An array of values.
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.Map">
            <summary>
            A map of values with string keys.
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.Union">
            <summary>
            A union.
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.Fixed">
            <summary>
            A fixed-length byte string.
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.Error">
            <summary>
            A protocol error.
            </summary>
        </member>
        <member name="F:Avro.Schema.Type.Logical">
            <summary>
            A logical type.
            </summary>
        </member>
        <member name="P:Avro.Schema.Tag">
            <summary>
            Schema type property
            </summary>
        </member>
        <member name="P:Avro.Schema.Props">
            <summary>
            Additional JSON attributes apart from those defined in the AVRO spec
            </summary>
        </member>
        <member name="M:Avro.Schema.#ctor(Avro.Schema.Type,Avro.PropertyMap)">
            <summary>
            Constructor for schema class
            </summary>
            <param name="type"></param>
            <param name="props">dictionary that provides access to custom properties</param>
        </member>
        <member name="P:Avro.Schema.Name">
            <summary>
            If this is a record, enum or fixed, returns its name, otherwise the name the primitive type.
            </summary>
        </member>
        <member name="P:Avro.Schema.Fullname">
            <summary>
            The name of this schema. If this is a named schema such as an enum, it returns the fully qualified
            name for the schema. For other schemas, it returns the type of the schema.
            </summary>
        </member>
        <member name="M:Avro.Schema.ParseJson(Newtonsoft.Json.Linq.JToken,Avro.SchemaNames,System.String)">
            <summary>
            Static class to return new instance of schema object
            </summary>
            <param name="jtok">JSON object</param>
            <param name="names">list of named schemas already read</param>
            <param name="encspace">enclosing namespace of the schema</param>
            <returns>new Schema object</returns>
        </member>
        <member name="M:Avro.Schema.Parse(System.String)">
            <summary>
            Parses a given JSON string to create a new schema object
            </summary>
            <param name="json">JSON string</param>
            <returns>new Schema object</returns>
        </member>
        <member name="M:Avro.Schema.Parse(System.String,Avro.SchemaNames,System.String)">
            <summary>
            Parses a JSON string to create a new schema object
            </summary>
            <param name="json">JSON string</param>
            <param name="names">list of named schemas already read</param>
            <param name="encspace">enclosing namespace of the schema</param>
            <returns>new Schema object</returns>
        </member>
        <member name="M:Avro.Schema.GetProperties(Newtonsoft.Json.Linq.JToken)">
            <summary>
            Static function to parse custom properties (not defined in the Avro spec) from the given JSON object
            </summary>
            <param name="jtok">JSON object to parse</param>
            <returns>Property map if custom properties were found, null if no custom properties found</returns>
        </member>
        <member name="M:Avro.Schema.ToString">
            <summary>
            Returns the canonical JSON representation of this schema.
            </summary>
            <returns>The canonical JSON representation of this schema.</returns>
        </member>
        <member name="M:Avro.Schema.writeStartObject(Newtonsoft.Json.JsonTextWriter)">
            <summary>
            Writes opening { and 'type' property
            </summary>
            <param name="writer">JSON writer</param>
        </member>
        <member name="M:Avro.Schema.GetTypeString(Avro.Schema.Type)">
            <summary>
            Returns symbol name for the given schema type
            </summary>
            <param name="type">schema type</param>
            <returns>symbol name</returns>
        </member>
        <member name="M:Avro.Schema.WriteJsonFields(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames,System.String)">
            <summary>
            Default implementation for writing schema properties in JSON format
            </summary>
            <param name="writer">JSON writer</param>
            <param name="names">list of named schemas already written</param>
            <param name="encspace">enclosing namespace of the schema</param>
        </member>
        <member name="M:Avro.Schema.WriteJson(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames,System.String)">
            <summary>
            Writes schema object in JSON format
            </summary>
            <param name="writer">JSON writer</param>
            <param name="names">list of named schemas already written</param>
            <param name="encspace">enclosing namespace of the schema</param>
        </member>
        <member name="M:Avro.Schema.GetProperty(System.String)">
            <summary>
            Returns the schema's custom property value given the property name
            </summary>
            <param name="key">custom property name</param>
            <returns>custom property value</returns>
        </member>
        <member name="M:Avro.Schema.GetHashCode">
            <summary>
            Hash code function
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.Schema.CanRead(Avro.Schema)">
            <summary>
            Returns true if and only if data written using writerSchema can be read using the current schema
            according to the Avro resolution rules.
            </summary>
            <param name="writerSchema">The writer's schema to match against.</param>
            <returns>True if and only if the current schema matches the writer's.</returns>
        </member>
        <member name="M:Avro.Schema.areEqual(System.Object,System.Object)">
            <summary>
            Compares two objects, null is equal to null
            </summary>
            <param name="o1">first object</param>
            <param name="o2">second object</param>
            <returns>true if two objects are equal, false otherwise</returns>
        </member>
        <member name="M:Avro.Schema.getHashCode(System.Object)">
            <summary>
            Hash code helper function
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:Avro.SchemaName">
            <summary>
            Class to store schema name, namespace, enclosing namespace and documentation
            </summary>
        </member>
        <member name="P:Avro.SchemaName.Name">
            <summary>
            Name of the schema
            </summary>
        </member>
        <member name="P:Avro.SchemaName.Space">
            <summary>
            Namespace specified within the schema
            </summary>
        </member>
        <member name="P:Avro.SchemaName.EncSpace">
            <summary>
            Namespace from the most tightly enclosing schema
            </summary>
        </member>
        <member name="P:Avro.SchemaName.Documentation">
            <summary>
            Documentation for the schema
            </summary>
        </member>
        <member name="P:Avro.SchemaName.Fullname">
            <summary>
            Namespace.Name of the schema
            </summary>
        </member>
        <member name="P:Avro.SchemaName.Namespace">
            <summary>
            Namespace of the schema
            </summary>
        </member>
        <member name="M:Avro.SchemaName.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            Constructor for SchemaName
            </summary>
            <param name="name">name of the schema</param>
            <param name="space">namespace of the schema</param>
            <param name="encspace">enclosing namespace of the schema</param>
            <param name="documentation">documentation o fthe schema</param>
        </member>
        <member name="M:Avro.SchemaName.ToString">
            <summary>
            Returns the full name of the schema
            </summary>
            <returns></returns>
        </member>
        <member name="M:Avro.SchemaName.WriteJson(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames,System.String)">
            <summary>
            Writes the schema name in JSON format
            </summary>
            <param name="writer">JSON writer</param>
            <param name="names">list of named schemas already written</param>
            <param name="encspace">enclosing namespace of the schema</param>
        </member>
        <member name="M:Avro.SchemaName.Equals(System.Object)">
            <summary>
            Compares two schema names
            </summary>
            <param name="obj">SchameName object to compare against this object</param>
            <returns>true or false</returns>
        </member>
        <member name="M:Avro.SchemaName.areEqual(System.Object,System.Object)">
            <summary>
            Compares two objects
            </summary>
            <param name="obj1">first object</param>
            <param name="obj2">second object</param>
            <returns>true or false</returns>
        </member>
        <member name="M:Avro.SchemaName.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Avro.SchemaNames">
            <summary>
            A class that contains a list of named schemas. This is used when reading or writing a schema/protocol.
            This prevents reading and writing of duplicate schema definitions within a protocol or schema file
            </summary>
        </member>
        <member name="P:Avro.SchemaNames.Names">
            <summary>
            Map of schema name and named schema objects
            </summary>
        </member>
        <member name="M:Avro.SchemaNames.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Avro.SchemaNames.Contains(Avro.SchemaName)">
            <summary>
            Checks if given name is in the map
            </summary>
            <param name="name">schema name</param>
            <returns>true or false</returns>
        </member>
        <member name="M:Avro.SchemaNames.Add(Avro.SchemaName,Avro.NamedSchema)">
            <summary>
            Adds a schema name to the map if it doesn't exist yet
            </summary>
            <param name="name">schema name</param>
            <param name="schema">schema object</param>
            <returns>true if schema was added to the list, false if schema is already in the list</returns>
        </member>
        <member name="M:Avro.SchemaNames.Add(Avro.NamedSchema)">
            <summary>
            Adds a named schema to the list
            </summary>
            <param name="schema">schema object</param>
            <returns>true if schema was added to the list, false if schema is already in the list</returns>
        </member>
        <member name="M:Avro.SchemaNames.TryGetValue(System.String,System.String,System.String,System.String,Avro.NamedSchema@)">
            <summary>
            Tries to get the value for the given name fields
            </summary>
            <param name="name">name of the schema</param>
            <param name="space">namespace of the schema</param>
            <param name="encspace">enclosing namespace of the schema</param>
            <param name="documentation">documentation for the schema</param>
            <param name="schema">schema object found</param>
            <returns>true if name is found in the map, false otherwise</returns>
        </member>
        <member name="M:Avro.SchemaNames.GetEnumerator">
            <summary>
            Returns the enumerator for the map
            </summary>
            <returns></returns>
        </member>
        <member name="T:Avro.SchemaNormalization">
            <summary>
            Collection of static methods for generating the cannonical form of schemas.
            </summary>
        </member>
        <member name="F:Avro.SchemaNormalization.Empty64">
             <summary>
             Obsolete: This will be removed from the public API in a future version.
             This should be a private const field, similar to the Java implementation. It appears
             that this was originally exposed for unit tests. Unit tests should hard-code this value
             rather than access it here.
            
             NOTE: When this is made private, remove the obsolete warning suppression around usages
             of this field in this class.
             </summary>
        </member>
        <member name="M:Avro.SchemaNormalization.ToParsingForm(Avro.Schema)">
            <summary>
            Parses a schema into the canonical form as defined by Avro spec.
            </summary>
            <param name="s">Schema</param>
            <returns>Parsing Canonical Form of a schema as defined by Avro spec.</returns>
        </member>
        <member name="M:Avro.SchemaNormalization.Fingerprint(System.String,System.Byte[])">
            <summary>
            <para>Returns a fingerprint of a string of bytes. This string is
            presumed to contain a canonical form of a schema. The
            algorithm used to compute the fingerprint is selected by the
            argument <i>fpName</i>.
            </para>
            <para>If <i>fpName</i> equals the string
            <code>"CRC-64-AVRO"</code>, then the result of <see cref="M:Avro.SchemaNormalization.Fingerprint64(System.Byte[])"/> is
            returned in little-endian format.
            </para>
            <para>If <i>fpName</i> equals the string
            <code>"MD5"</code>, then the standard MD5 algorithm is used.
            </para>
            <para>If <i>fpName</i> equals the string
            <code>"SHA-256"</code>, then the standard SHA-256 algorithm is used.
            </para>
            <para>Otherwise, <i>fpName</i> is
            not recognized and an
            <code>ArgumentException</code> is thrown
            </para>
            <para> Recommended Avro practice dictiates that
            <code>"CRC-64-AVRO"</code> is used for 64-bit fingerprints,
            <code>"MD5"</code> is used for 128-bit fingerprints, and
            <code>"SHA-256"</code> is used for 256-bit fingerprints.
            </para>
            </summary>
            <param name="fpName">Name of the hashing algorithm.</param>
            <param name="data">Data to be hashed.</param>
            <returns>Fingerprint</returns>
        </member>
        <member name="M:Avro.SchemaNormalization.ParsingFingerprint(System.String,Avro.Schema)">
            <summary>
            Returns <see cref="M:Avro.SchemaNormalization.Fingerprint(System.String,System.Byte[])"/> applied to the parsing canonical form of the supplied schema.
            </summary>
            <param name="fpName">Name of the hashing algorithm.</param>
            <param name="s">Schema to be hashed.</param>
            <returns>Fingerprint</returns>
        </member>
        <member name="M:Avro.SchemaNormalization.ParsingFingerprint64(Avro.Schema)">
            <summary>
            Returns <see cref="M:Avro.SchemaNormalization.Fingerprint64(System.Byte[])"/> applied to the parsing canonical form of the supplied schema.
            </summary>
            <param name="s">Schema to be hashed.</param>
            <returns>Fingerprint</returns>
        </member>
        <member name="M:Avro.SchemaNormalization.Fingerprint64(System.Byte[])">
            <summary>
            Computes the 64-bit Rabin Fingerprint (as recommended in the Avro spec) of a byte string.
            </summary>
            <param name="data">Data to be hashed.</param>
            <returns>Fingerprint</returns>
        </member>
        <member name="T:Avro.SchemaParseException">
            <summary>
            Used to communicate an exception that occurred while parsing a schema.
            </summary>
        </member>
        <member name="M:Avro.SchemaParseException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.SchemaParseException"/> class.
            </summary>
        </member>
        <member name="M:Avro.SchemaParseException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.SchemaParseException"/> class.
            </summary>
            <param name="s">Exception message.</param>
        </member>
        <member name="M:Avro.SchemaParseException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.SchemaParseException"/> class.
            </summary>
            <param name="message">
            The error message that explains the reason for the exception.
            </param>
            <param name="innerException">
            The exception that is the cause of the current exception, or a null reference if no
            inner exception is specified.
            </param>
        </member>
        <member name="T:Avro.UnionSchema">
            <summary>
            Class for union schemas
            </summary>
        </member>
        <member name="P:Avro.UnionSchema.Schemas">
            <summary>
            List of schemas in the union
            </summary>
        </member>
        <member name="P:Avro.UnionSchema.Count">
            <summary>
            Count of schemas in the union
            </summary>
        </member>
        <member name="M:Avro.UnionSchema.NewInstance(Newtonsoft.Json.Linq.JArray,Avro.PropertyMap,Avro.SchemaNames,System.String)">
            <summary>
            Static function to return instance of the union schema
            </summary>
            <param name="jarr">JSON object for the union schema</param>
            <param name="props">dictionary that provides access to custom properties</param>
            <param name="names">list of named schemas already read</param>
            <param name="encspace">enclosing namespace of the schema</param>
            <returns>new UnionSchema object</returns>
        </member>
        <member name="M:Avro.UnionSchema.#ctor(System.Collections.Generic.List{Avro.Schema},Avro.PropertyMap)">
            <summary>
            Contructor for union schema
            </summary>
            <param name="schemas"></param>
            <param name="props">dictionary that provides access to custom properties</param>
        </member>
        <member name="P:Avro.UnionSchema.Item(System.Int32)">
            <summary>
            Returns the schema at the given branch.
            </summary>
            <param name="index">Index to the branch, starting with 0.</param>
            <returns>The branch corresponding to the given index.</returns>
        </member>
        <member name="M:Avro.UnionSchema.WriteJson(Newtonsoft.Json.JsonTextWriter,Avro.SchemaNames,System.String)">
            <summary>
            Writes union schema in JSON format
            </summary>
            <param name="writer">JSON writer</param>
            <param name="names">list of named schemas already written</param>
            <param name="encspace">enclosing namespace of the schema</param>
        </member>
        <member name="M:Avro.UnionSchema.MatchingBranch(Avro.Schema)">
            <summary>
            Returns the index of a branch that can read the data written by the given schema s.
            </summary>
            <param name="s">The schema to match the branches against.</param>
            <returns>The index of the matching branch. If non matches a -1 is returned.</returns>
        </member>
        <member name="M:Avro.UnionSchema.CanRead(Avro.Schema)">
            <summary>
            Checks if this schema can read data written by the given schema. Used for decoding data.
            </summary>
            <param name="writerSchema">writer schema</param>
            <returns>true if this and writer schema are compatible based on the AVRO specification, false otherwise</returns>
        </member>
        <member name="M:Avro.UnionSchema.Equals(System.Object)">
            <summary>
            Compares two union schema objects
            </summary>
            <param name="obj">union schema object to compare against this schema</param>
            <returns>true if objects are equal, false otherwise</returns>
        </member>
        <member name="M:Avro.UnionSchema.GetHashCode">
            <summary>
            Hash code function
            </summary>
            <returns></returns>
        </member>
        <member name="T:Avro.UnnamedSchema">
            <summary>
            Base class for all unnamed schemas
            </summary>
        </member>
        <member name="M:Avro.UnnamedSchema.#ctor(Avro.Schema.Type,Avro.PropertyMap)">
            <summary>
            Base constructor for an <see cref="T:Avro.UnnamedSchema"/>.
            </summary>
            <param name="type">Type of schema.</param>
            <param name="props">Dictionary that provides access to custom properties</param>
        </member>
        <member name="P:Avro.UnnamedSchema.Name">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Specific.ObjectCreator">
            <summary>
            Resolves and creates types associated with a schema and/or name. You should generally use
            the shared <see cref="P:Avro.Specific.ObjectCreator.Instance"/> to take advantage caching.
            </summary>
        </member>
        <member name="P:Avro.Specific.ObjectCreator.Instance">
            <summary>
            Shareable instance of the <see cref="T:Avro.Specific.ObjectCreator"/>.
            </summary>
        </member>
        <member name="F:Avro.Specific.ObjectCreator.GenericMapType">
            <summary>
            Static generic dictionary type used for creating new dictionary instances
            </summary>
        </member>
        <member name="F:Avro.Specific.ObjectCreator.GenericListType">
            <summary>
            Static generic list type used for creating new array instances
            </summary>
        </member>
        <member name="F:Avro.Specific.ObjectCreator.GenericIListType">
            <summary>
            Static generic list type used for creating new IList instances
            </summary>
        </member>
        <member name="F:Avro.Specific.ObjectCreator.GenericNullableType">
            <summary>
            Static generic nullable type used for creating new nullable instances
            </summary>
        </member>
        <member name="T:Avro.Specific.ObjectCreator.CtorDelegate">
            <summary>
            Obsolete: This will be removed from the public API in a future version.
            </summary>
            <returns>Obsolete</returns>
        </member>
        <member name="M:Avro.Specific.ObjectCreator.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Specific.ObjectCreator"/> class.
            </summary>
        </member>
        <member name="T:Avro.Specific.ObjectCreator.NameCtorKey">
            <summary>
            Obsolete: This will be removed from the public API in a future version.
            </summary>
        </member>
        <member name="M:Avro.Specific.ObjectCreator.FindType(System.String)">
            <summary>
            Find the type with the given name
            </summary>
            <param name="name">the object type to locate</param>
            <returns>the object type, or <c>null</c> if not found</returns>
            <exception cref="T:Avro.AvroException">
            No type found matching the given name.
            </exception>
        </member>
        <member name="M:Avro.Specific.ObjectCreator.GetType(Avro.Schema)">
            <summary>
            Gets the type for the specified schema
            </summary>
            <param name="schema"></param>
            <returns></returns>
            <exception cref="T:Avro.AvroException">
            No type found matching the given name.
            </exception>
        </member>
        <member name="M:Avro.Specific.ObjectCreator.GetType(System.String,Avro.Schema.Type)">
            <summary>
            Gets the type of the specified type name
            </summary>
            <param name="name">name of the object to get type of</param>
            <param name="schemaType">schema type for the object</param>
            <returns>Type</returns>
            <exception cref="T:Avro.AvroException">
            No type found matching the given name.
            </exception>
        </member>
        <member name="M:Avro.Specific.ObjectCreator.New(System.String,Avro.Schema.Type)">
            <summary>
            Creates new instance of the given type
            </summary>
            <param name="name">fully qualified name of the type</param>
            <param name="schemaType">type of schema</param>
            <returns>new object of the given type</returns>
            <exception cref="T:Avro.AvroException">
            No type found matching the given name.
            </exception>
        </member>
        <member name="T:Avro.Specific.SpecificDatumReader`1">
            <summary>
            PreresolvingDatumReader for reading data to ISpecificRecord classes.
            </summary>
            <see cref="T:Avro.Generic.PreresolvingDatumReader`1">For more information about performance considerations for choosing this implementation</see>
        </member>
        <member name="M:Avro.Specific.SpecificDatumReader`1.#ctor(Avro.Schema,Avro.Schema)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Specific.SpecificDatumReader`1"/> class.
            </summary>
            <param name="writerSchema">Schema that was used to write the data.</param>
            <param name="readerSchema">Schema to use when reading the data.</param>
        </member>
        <member name="M:Avro.Specific.SpecificDatumReader`1.IsReusable(Avro.Schema.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Specific.SpecificDatumReader`1.GetArrayAccess(Avro.ArraySchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Specific.SpecificDatumReader`1.GetEnumAccess(Avro.EnumSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Specific.SpecificDatumReader`1.GetMapAccess(Avro.MapSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Specific.SpecificDatumReader`1.GetRecordAccess(Avro.RecordSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Specific.SpecificDatumReader`1.GetFixedAccess(Avro.FixedSchema)">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Specific.SpecificDatumWriter`1">
            <summary>
            PreresolvingDatumWriter for writing data from ISpecificRecord classes.
            </summary>
            <see cref="T:Avro.Generic.PreresolvingDatumWriter`1">For more information about performance considerations for choosing this implementation</see>
        </member>
        <member name="M:Avro.Specific.SpecificDatumWriter`1.#ctor(Avro.Schema)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Specific.SpecificDatumWriter`1"/> class.
            </summary>
            <param name="schema">Schema to use when writing data.</param>
        </member>
        <member name="M:Avro.Specific.SpecificDatumWriter`1.WriteRecordFields(System.Object,Avro.Generic.PreresolvingDatumWriter{`0}.RecordFieldWriter[],Avro.IO.Encoder)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Specific.SpecificDatumWriter`1.EnsureRecordObject(Avro.RecordSchema,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Specific.SpecificDatumWriter`1.WriteField(System.Object,System.String,System.Int32,Avro.Generic.PreresolvingDatumWriter{`0}.WriteItem,Avro.IO.Encoder)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Specific.SpecificDatumWriter`1.ResolveEnum(Avro.EnumSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Specific.SpecificDatumWriter`1.WriteFixed(Avro.FixedSchema,System.Object,Avro.IO.Encoder)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Specific.SpecificDatumWriter`1.UnionBranchMatches(Avro.Schema,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Specific.SpecificException">
            <summary>
            Base class for specific exceptions.
            </summary>
        </member>
        <member name="M:Avro.Specific.SpecificException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Specific.SpecificException"/> class.
            </summary>
        </member>
        <member name="M:Avro.Specific.SpecificException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Specific.SpecificException"/> class.
            </summary>
            <param name="message">
            The error message that explains the reason for the exception.
            </param>
        </member>
        <member name="M:Avro.Specific.SpecificException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Specific.SpecificException"/> class.
            </summary>
            <param name="message">
            The error message that explains the reason for the exception.
            </param>
            <param name="innerException">
            The exception that is the cause of the current exception, or a null reference if no
            inner exception is specified.
            </param>
        </member>
        <member name="P:Avro.Specific.SpecificException.Schema">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Specific.SpecificException.Get(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Specific.SpecificException.Put(System.Int32,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Specific.SpecificFixed">
            <summary>
            Base class for all generated classes
            </summary>
        </member>
        <member name="M:Avro.Specific.SpecificFixed.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Specific.SpecificFixed"/> class.
            </summary>
            <param name="size"></param>
        </member>
        <member name="P:Avro.Specific.SpecificFixed.Schema">
            <summary>
            Schema of this instance.
            </summary>
        </member>
        <member name="M:Avro.Specific.SpecificFixed.Equals(Avro.Specific.SpecificFixed)">
            <summary>
            Determines whether the provided fixed is equivalent this this instance.
            </summary>
            <param name="obj">Fixed to compare.</param>
            <returns>True if the fixed instances have equal values.</returns>
        </member>
        <member name="M:Avro.Specific.SpecificFixed.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Specific.SpecificFixed.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Specific.ISpecificProtocol">
            <summary>
            Defines the interface for a class that implements a specific protocol.
            TODO: This interface needs better documentation.
            </summary>
        </member>
        <member name="P:Avro.Specific.ISpecificProtocol.Protocol">
            <summary>
            Protocol for this instance.
            </summary>
        </member>
        <member name="M:Avro.Specific.ISpecificProtocol.Request(Avro.Specific.ICallbackRequestor,System.String,System.Object[],System.Object)">
            <summary>
            Execute a request.
            </summary>
            <param name="requestor">Callback requestor.</param>
            <param name="messageName">Name of the message.</param>
            <param name="args">Arguments for the message.</param>
            <param name="callback">Callback.</param>
        </member>
        <member name="T:Avro.Specific.ICallbackRequestor">
            <summary>
            TODO: This interface needs better documentation.
            </summary>
        </member>
        <member name="M:Avro.Specific.ICallbackRequestor.Request``1(System.String,System.Object[],System.Object)">
            <summary>
            Request
            </summary>
            <typeparam name="T">Type</typeparam>
            <param name="messageName">Name of the message.</param>
            <param name="args">Arguments for the message.</param>
            <param name="callback">Callback.</param>
        </member>
        <member name="T:Avro.Specific.SpecificReader`1">
            <summary>
            Reader wrapper class for reading data and storing into specific classes
            </summary>
            <typeparam name="T">Specific class type</typeparam>
        </member>
        <member name="F:Avro.Specific.SpecificReader`1.reader">
            <summary>
            Reader class for reading data and storing into specific classes
            </summary>
        </member>
        <member name="P:Avro.Specific.SpecificReader`1.WriterSchema">
            <summary>
            Schema for the writer class
            </summary>
        </member>
        <member name="P:Avro.Specific.SpecificReader`1.ReaderSchema">
            <summary>
            Schema for the reader class
            </summary>
        </member>
        <member name="M:Avro.Specific.SpecificReader`1.#ctor(Avro.Schema,Avro.Schema)">
            <summary>
            Constructs a generic reader for the given schemas using the DefaultReader. If the
            reader's and writer's schemas are different this class performs the resolution.
            </summary>
            <param name="writerSchema">The schema used while generating the data</param>
            <param name="readerSchema">The schema desired by the reader</param>
        </member>
        <member name="M:Avro.Specific.SpecificReader`1.#ctor(Avro.Specific.SpecificDefaultReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Specific.SpecificReader`1"/> class using an
            existing <see cref="T:Avro.Specific.SpecificDefaultReader"/>.
            </summary>
            <param name="reader">Default reader to use.</param>
        </member>
        <member name="M:Avro.Specific.SpecificReader`1.Read(`0,Avro.IO.Decoder)">
            <summary>
            Generic read function
            </summary>
            <param name="reuse">object to store data read</param>
            <param name="dec">decorder to use for reading data</param>
            <returns></returns>
        </member>
        <member name="T:Avro.Specific.SpecificDefaultReader">
            <summary>
            Reader class for reading data and storing into specific classes
            </summary>
        </member>
        <member name="M:Avro.Specific.SpecificDefaultReader.#ctor(Avro.Schema,Avro.Schema)">
            <summary>
            Constructor
            </summary>
            <param name="writerSchema">schema of the object that wrote the data</param>
            <param name="readerSchema">schema of the object that will store the data</param>
        </member>
        <member name="M:Avro.Specific.SpecificDefaultReader.ReadRecord(System.Object,Avro.RecordSchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Deserializes a record from the stream.
            </summary>
            <param name="reuse">If not null, a record object that could be reused for returning the result</param>
            <param name="writerSchema">The writer's RecordSchema</param>
            <param name="readerSchema">The reader's schema, must be RecordSchema too.</param>
            <param name="dec">The decoder for deserialization</param>
            <returns>The record object just read</returns>
        </member>
        <member name="M:Avro.Specific.SpecificDefaultReader.ReadFixed(System.Object,Avro.FixedSchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Deserializes a fixed object and returns the object. The default implementation uses CreateFixed()
            and GetFixedBuffer() and returns what CreateFixed() returned.
            </summary>
            <param name="reuse">If appropriate, uses this object instead of creating a new one.</param>
            <param name="writerSchema">The FixedSchema the writer used during serialization.</param>
            <param name="readerSchema">The schema that the readr uses. Must be a FixedSchema with the same
            size as the writerSchema.</param>
            <param name="d">The decoder for deserialization.</param>
            <returns>The deserilized object.</returns>
        </member>
        <member name="M:Avro.Specific.SpecificDefaultReader.ReadEnum(System.Object,Avro.EnumSchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Reads an enum from the given decoder
            </summary>
            <param name="reuse">object to store data read</param>
            <param name="writerSchema">schema of the object that wrote the data</param>
            <param name="readerSchema">schema of the object that will store the data</param>
            <param name="dec">decoder object that contains the data to be read</param>
            <returns>enum value</returns>
        </member>
        <member name="M:Avro.Specific.SpecificDefaultReader.ReadArray(System.Object,Avro.ArraySchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Reads an array from the given decoder
            </summary>
            <param name="reuse">object to store data read</param>
            <param name="writerSchema">schema of the object that wrote the data</param>
            <param name="readerSchema">schema of the object that will store the data</param>
            <param name="dec">decoder object that contains the data to be read</param>
            <returns>array</returns>
        </member>
        <member name="M:Avro.Specific.SpecificDefaultReader.ReadMap(System.Object,Avro.MapSchema,Avro.Schema,Avro.IO.Decoder)">
            <summary>
            Deserialized an avro map. The default implemenation creats a new map using CreateMap() and then
            adds elements to the map using AddMapEntry().
            </summary>
            <param name="reuse">If appropriate, use this instead of creating a new map object.</param>
            <param name="writerSchema">The schema the writer used to write the map.</param>
            <param name="readerSchema">The schema the reader is using.</param>
            <param name="d">The decoder for serialization.</param>
            <returns>The deserialized map object.</returns>
        </member>
        <member name="M:Avro.Specific.SpecificDefaultReader.getTargetType(Avro.Schema)">
            <summary>
            Gets the target type name in the given schema
            </summary>
            <param name="schema">schema containing the type to be determined</param>
            <returns>Name of the type</returns>
        </member>
        <member name="T:Avro.Specific.ISpecificRecord">
            <summary>
            Interface class for generated classes
            </summary>
        </member>
        <member name="P:Avro.Specific.ISpecificRecord.Schema">
            <summary>
            Schema of this instance.
            </summary>
        </member>
        <member name="M:Avro.Specific.ISpecificRecord.Get(System.Int32)">
            <summary>
            Return the value of a field given its position in the schema.
            This method is not meant to be called by user code, but only by
            <see cref="T:Avro.Specific.SpecificDatumReader`1"/> implementations.
            </summary>
            <param name="fieldPos">Position of the field.</param>
            <returns>Value of the field.</returns>
        </member>
        <member name="M:Avro.Specific.ISpecificRecord.Put(System.Int32,System.Object)">
            <summary>
            Set the value of a field given its position in the schema.
            This method is not meant to be called by user code, but only by
            <see cref="T:Avro.Specific.SpecificDatumWriter`1"/> implementations.
            </summary>
            <param name="fieldPos">Position of the field.</param>
            <param name="fieldValue">Value of the field.</param>
        </member>
        <member name="T:Avro.Specific.SpecificWriter`1">
            <summary>
            Generic wrapper class for writing data from specific objects
            </summary>
            <typeparam name="T">type name of specific object</typeparam>
        </member>
        <member name="M:Avro.Specific.SpecificWriter`1.#ctor(Avro.Schema)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Specific.SpecificWriter`1"/> class.
            </summary>
            <param name="schema">Schema to use when writing.</param>
        </member>
        <member name="M:Avro.Specific.SpecificWriter`1.#ctor(Avro.Specific.SpecificDefaultWriter)">
            <summary>
            Initializes a new instance of the <see cref="T:Avro.Specific.SpecificWriter`1"/> class using the
            provided <see cref="T:Avro.Specific.SpecificDefaultWriter"/>.
            </summary>
            <param name="writer">Default writer to use.</param>
        </member>
        <member name="T:Avro.Specific.SpecificDefaultWriter">
            <summary>
            Class for writing data from any specific objects
            </summary>
        </member>
        <member name="M:Avro.Specific.SpecificDefaultWriter.#ctor(Avro.Schema)">
            <summary>
            Constructor
            </summary>
            <param name="schema">schema of the object to be written</param>
        </member>
        <member name="M:Avro.Specific.SpecificDefaultWriter.WriteRecord(Avro.RecordSchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Serialized a record using the given RecordSchema. It uses GetField method
            to extract the field value from the given object.
            </summary>
            <param name="schema">The RecordSchema to use for serialization</param>
            <param name="value">The value to be serialized</param>
            <param name="encoder">The Encoder for serialization</param>
        </member>
        <member name="M:Avro.Specific.SpecificDefaultWriter.WriteFixed(Avro.FixedSchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Validates that the record is a fixed record object and that the schema in the object is the
            same as the given writer schema. Writes the given fixed record into the given encoder
            </summary>
            <param name="schema">writer schema</param>
            <param name="value">fixed object to write</param>
            <param name="encoder">encoder to write to</param>
        </member>
        <member name="M:Avro.Specific.SpecificDefaultWriter.WriteEnum(Avro.EnumSchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Writes the given enum value into the given encoder.
            </summary>
            <param name="schema">writer schema</param>
            <param name="value">enum value</param>
            <param name="encoder">encoder to write to</param>
        </member>
        <member name="M:Avro.Specific.SpecificDefaultWriter.WriteArray(Avro.ArraySchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Serialized an array. The default implementation calls EnsureArrayObject() to ascertain that the
            given value is an array. It then calls GetArrayLength() and GetArrayElement()
            to access the members of the array and then serialize them.
            </summary>
            <param name="schema">The ArraySchema for serialization</param>
            <param name="value">The value being serialized</param>
            <param name="encoder">The encoder for serialization</param>
        </member>
        <member name="M:Avro.Specific.SpecificDefaultWriter.WriteMap(Avro.MapSchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Writes the given map into the given encoder.
            </summary>
            <param name="schema">writer schema</param>
            <param name="value">map to write</param>
            <param name="encoder">encoder to write to</param>
        </member>
        <member name="M:Avro.Specific.SpecificDefaultWriter.WriteUnion(Avro.UnionSchema,System.Object,Avro.IO.Encoder)">
            <summary>
            Resolves the given value against the given UnionSchema and serializes the object against
            the resolved schema member. The default implementation of this method uses
            ResolveUnion to find the member schema within the UnionSchema.
            </summary>
            <param name="us">The UnionSchema to resolve against</param>
            <param name="value">The value to be serialized</param>
            <param name="encoder">The encoder for serialization</param>
        </member>
        <member name="M:Avro.Specific.SpecificDefaultWriter.Matches(Avro.Schema,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Util.Date">
            <summary>
            The 'date' logical type.
            </summary>
        </member>
        <member name="F:Avro.Util.Date.LogicalTypeName">
            <summary>
            The logical type name for Date.
            </summary>
        </member>
        <member name="M:Avro.Util.Date.#ctor">
            <summary>
            Initializes a new Date logical type.
            </summary>
        </member>
        <member name="M:Avro.Util.Date.ValidateSchema(Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Util.Date.ConvertToBaseValue(System.Object,Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Util.Date.ConvertToLogicalValue(System.Object,Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Util.Decimal">
            <summary>
            The 'decimal' logical type.
            </summary>
        </member>
        <member name="F:Avro.Util.Decimal.LogicalTypeName">
            <summary>
            The logical type name for Decimal.
            </summary>
        </member>
        <member name="M:Avro.Util.Decimal.#ctor">
            <summary>
            Initializes a new Decimal logical type.
            </summary>
        </member>
        <member name="M:Avro.Util.Decimal.ValidateSchema(Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Util.Decimal.ConvertToBaseValue(System.Object,Avro.LogicalSchema)">
            <inheritdoc/>      
        </member>
        <member name="M:Avro.Util.Decimal.ConvertToLogicalValue(System.Object,Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Util.Decimal.GetCSharpType(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Util.Decimal.IsInstanceOfLogicalType(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Util.LogicalType">
            <summary>
            Base for all logical type implementations.
            </summary>
        </member>
        <member name="P:Avro.Util.LogicalType.Name">
            <summary>
            The logical type name.
            </summary>
        </member>
        <member name="M:Avro.Util.LogicalType.#ctor(System.String)">
            <summary>
            Initializes the base logical type.
            </summary>
            <param name="name">The logical type name.</param>
        </member>
        <member name="M:Avro.Util.LogicalType.ValidateSchema(Avro.LogicalSchema)">
            <summary>
            Applies logical type validation for a given logical schema.
            </summary>
            <param name="schema">The schema to be validated.</param>
        </member>
        <member name="M:Avro.Util.LogicalType.ConvertToBaseValue(System.Object,Avro.LogicalSchema)">
            <summary>
            Converts a logical value to an instance of its base type.
            </summary>
            <param name="logicalValue">The logical value to convert.</param>
            <param name="schema">The schema that represents the target of the conversion.</param>
            <returns>An object representing the encoded value of the base type.</returns>
        </member>
        <member name="M:Avro.Util.LogicalType.ConvertToLogicalValue(System.Object,Avro.LogicalSchema)">
            <summary>
            Converts a base value to an instance of the logical type.
            </summary>
            <param name="baseValue">The base value to convert.</param>
            <param name="schema">The schema that represents the target of the conversion.</param>
            <returns>An object representing the encoded value of the logical type.</returns>
        </member>
        <member name="M:Avro.Util.LogicalType.GetCSharpType(System.Boolean)">
            <summary>
            Retrieve the .NET type that is represented by the logical type implementation.
            </summary>
            <param name="nullible">A flag indicating whether it should be nullible.</param>
        </member>
        <member name="M:Avro.Util.LogicalType.IsInstanceOfLogicalType(System.Object)">
            <summary>
            Determines if a given object is an instance of the logical type.
            </summary>
            <param name="logicalValue">The logical value to test.</param>
        </member>
        <member name="T:Avro.Util.LogicalTypeFactory">
            <summary>
            A factory for logical type implementations.
            </summary>
        </member>
        <member name="P:Avro.Util.LogicalTypeFactory.Instance">
            <summary>
            Returns the <see cref="T:Avro.Util.LogicalTypeFactory" /> singleton.
            </summary>
            <returns>The <see cref="T:Avro.Util.LogicalTypeFactory" /> singleton. </returns>
        </member>
        <member name="M:Avro.Util.LogicalTypeFactory.Register(Avro.Util.LogicalType)">
            <summary>
            Registers or replaces a logical type implementation.
            </summary>
            <param name="logicalType">The <see cref="T:Avro.Util.LogicalType"/> implementation that should be registered.</param>
        </member>
        <member name="M:Avro.Util.LogicalTypeFactory.GetFromLogicalSchema(Avro.LogicalSchema,System.Boolean)">
            <summary>
            Retrieves a logical type implementation for a given logical schema.
            </summary>
            <param name="schema">The schema.</param>
            <param name="ignoreInvalidOrUnknown">A flag to indicate if an exception should be thrown for invalid
            or unknown logical types.</param>
            <returns>A <see cref="T:Avro.Util.LogicalType" />.</returns>
        </member>
        <member name="T:Avro.Util.LogicalUnixEpochType`1">
            <summary>
            Base for all logical type implementations that are based on the Unix Epoch date/time.
            </summary>
        </member>
        <member name="F:Avro.Util.LogicalUnixEpochType`1.UnixEpochDateTime">
            <summary>
            The date and time of the Unix Epoch.
            </summary>
        </member>
        <member name="M:Avro.Util.LogicalUnixEpochType`1.#ctor(System.String)">
            <summary>
            Initializes the base logical type.
            </summary>
            <param name="name">The logical type name.</param>
        </member>
        <member name="M:Avro.Util.LogicalUnixEpochType`1.GetCSharpType(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Util.LogicalUnixEpochType`1.IsInstanceOfLogicalType(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Util.TimeMicrosecond">
            <summary>
            The 'time-micros' logical type.
            </summary>
        </member>
        <member name="F:Avro.Util.TimeMicrosecond.LogicalTypeName">
            <summary>
            The logical type name for TimeMicrosecond.
            </summary>
        </member>
        <member name="M:Avro.Util.TimeMicrosecond.#ctor">
            <summary>
            Initializes a new TimeMicrosecond logical type.
            </summary>
        </member>
        <member name="M:Avro.Util.TimeMicrosecond.ValidateSchema(Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Util.TimeMicrosecond.ConvertToBaseValue(System.Object,Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Util.TimeMicrosecond.ConvertToLogicalValue(System.Object,Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Util.TimeMillisecond">
            <summary>
            The 'time-millis' logical type.
            </summary>
        </member>
        <member name="F:Avro.Util.TimeMillisecond.LogicalTypeName">
            <summary>
            The logical type name for TimeMillisecond.
            </summary>
        </member>
        <member name="M:Avro.Util.TimeMillisecond.#ctor">
            <summary>
            Initializes a new TimeMillisecond logical type.
            </summary>
        </member>
        <member name="M:Avro.Util.TimeMillisecond.ValidateSchema(Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Util.TimeMillisecond.ConvertToBaseValue(System.Object,Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Util.TimeMillisecond.ConvertToLogicalValue(System.Object,Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Util.TimestampMicrosecond">
            <summary>
            The 'timestamp-micros' logical type.
            </summary>
        </member>
        <member name="F:Avro.Util.TimestampMicrosecond.LogicalTypeName">
            <summary>
            The logical type name for TimestampMicrosecond.
            </summary>
        </member>
        <member name="M:Avro.Util.TimestampMicrosecond.#ctor">
            <summary>
            Initializes a new TimestampMicrosecond logical type.
            </summary>
        </member>
        <member name="M:Avro.Util.TimestampMicrosecond.ValidateSchema(Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Util.TimestampMicrosecond.ConvertToBaseValue(System.Object,Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Util.TimestampMicrosecond.ConvertToLogicalValue(System.Object,Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Util.TimestampMillisecond">
            <summary>
            The 'timestamp-millis' logical type.
            </summary>
        </member>
        <member name="F:Avro.Util.TimestampMillisecond.LogicalTypeName">
            <summary>
            The logical type name for TimestampMillisecond.
            </summary>
        </member>
        <member name="M:Avro.Util.TimestampMillisecond.#ctor">
            <summary>
            Initializes a new TimestampMillisecond logical type.
            </summary>
        </member>
        <member name="M:Avro.Util.TimestampMillisecond.ValidateSchema(Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Util.TimestampMillisecond.ConvertToBaseValue(System.Object,Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="M:Avro.Util.TimestampMillisecond.ConvertToLogicalValue(System.Object,Avro.LogicalSchema)">
            <inheritdoc/>
        </member>
        <member name="T:Avro.Util.Uuid">
            <summary>
            UUid logical type
            </summary>
        </member>
        <member name="F:Avro.Util.Uuid.LogicalTypeName">
            <summary>
            Logical type name
            </summary>
        </member>
        <member name="M:Avro.Util.Uuid.#ctor">
            <summary>
            Constructs Uuid object
            </summary>
        </member>
        <member name="M:Avro.Util.Uuid.ConvertToBaseValue(System.Object,Avro.LogicalSchema)">
            <inheritdoc />
        </member>
        <member name="M:Avro.Util.Uuid.ConvertToLogicalValue(System.Object,Avro.LogicalSchema)">
            <inheritdoc />
        </member>
        <member name="M:Avro.Util.Uuid.GetCSharpType(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Avro.Util.Uuid.IsInstanceOfLogicalType(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Avro.Util.Uuid.ValidateSchema(Avro.LogicalSchema)">
            <inheritdoc />
        </member>
    </members>
</doc>
